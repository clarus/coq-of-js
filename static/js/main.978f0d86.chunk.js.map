{"version":3,"sources":["compiler/monad.js","compiler/result.js","compiler/doc.js","compiler/identifier.js","compiler/util.js","compiler/typ.js","compiler/expression.js","compiler/typ-definition.js","compiler/top-level-statement.js","compiler/program.js","demoInput.js","Output.js","App.js","compiler/error.js","serviceWorker.js","index.js"],"names":["ret","all","raise","raiseUnhandled","value","expressions","type","reduce","array","accumulator","reducer","a","element","filterMap","f","result","some","predicate","areSome","node","message","JSON","stringify","runWithAnswer","expression","answer","next","done","nextAnswer","results","errors","Result","map","location","loc","doc","builders","concat","group","hardline","indent","join","line","softline","paren","needParens","nameMapping","Props","compile","identifier","name","getObjectKeyName","compileIdentifier","compileIfPlainTyp","key","Identifier","Monad","compileIdentifierOrQualifiedTypeIdentifier","id","qualification","typ","elementType","params","typeAnnotation","returnType","typeParameters","Util","param","returnTyp","typParams","properties","length","types","compiledTyp","printImplicitTyps","names","Doc","print","typParam","getObjectPropertyName","getLeftValueRecordFields","compileLVal","getStringOfStringLiteral","getFieldsDestructuringFromHeadStatement","compileStatements","compileFun","tt","property","Typ","pattern","variable","lval","typName","fields","record","isEmptyDefaultBranch","statements","statement","body","argument","discriminantName","noDestructuring","trailingStatements","headStatement","slice","declarations","declaration","init","discriminant","cases","trailingComments","trim","firstTrailingComment","object","consequent","test","branches","defaultCase","find","branch","defaultBranch","sum","accumulatedNames","currentAccumulatedNames","fun","arguments","typParameters","elements","left","operator","right","callee","alternate","field","spreads","computed","update","constr","instance","printFunArguments","funArguments","printCallExpression","args","printRecordInstance","printLeftValue","withQuote","printMatch","patterns","getObjectTypePropertyName","getStringOfStringLiteralTypeAnnotation","compileStringEnum","compileSumType","typs","nameProperties","fieldProperties","constructors","objectTyp","printModule","printRecord","withSetters","Expression","printDefineTypeAsModule","extractIdentifierOfLVal","source","TypDefinition","impltype","typDefinition","nextToken","module","constructor","program","TopLevelStatement","unflattenedStatements","CoqOutput","output","this","props","PureComponent","getInitialJsInput","window","item","sessionStorage","getItem","demoInput","ExternalLink","width","height","aria-hidden","viewBox","fill","d","App","state","jsInput","onChangeJsInput","event","currentTarget","setState","setItem","parse","plugins","sourceType","error","codeFrame","column","jsAst","Program","errorSourceCode","codeFrameColumns","Error","coqAst","printer","printDocToString","withHeader","programElement","printWidth","tabWidth","formatted","getJsAst","coq","getCoqAst","getCoqString","getOutputs","className","aria-label","role","href","rel","target","onChange","Boolean","hostname","match","rootElement","document","getElementById","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"wYAqBiBA,G,WAMAC,G,WA+BAC,G,WAIAC,GAzCV,SAAUH,EAAOI,GAAjB,yFACEA,GADF,sCAMA,SAAUH,EAAOI,GAAjB,gEACE,OADF,SACQ,CAACC,KAAM,MAAOD,eADtB,8EAIA,SAASE,EACdC,EACAC,EACAC,GAEA,OAAOF,EAAMD,OAAN,EAAAI,EAAA,KAAa,WAAUF,EAAaG,GAAvB,gEACI,OADJ,KACJF,EAAQ,gBAAOD,EAAP,QADJ,OACX,OADW,eACwBG,EAAnC,4CADW,8EAEjBZ,EAAIS,IAGF,SAASI,EAAgBL,EAAYM,GAC1C,OAAOP,EAAOC,EAAO,GAAR,SAAY,WAAUC,EAAkBG,GAA5B,sEACR,uBAAOE,EAAEF,GAAT,QADQ,cACjBG,EADiB,uBAGhBA,EAAM,sBAAON,GAAP,CAAoBM,IAAUN,GAHpB,yCAOpB,SAASO,EACdR,EACAS,GAEA,OAAOV,EAAOC,GAAO,EAAR,SAAe,WAAUU,EAASN,GAAnB,wEACnBM,EADmB,qBACP,uBAAOD,EAAUL,GAAjB,QADO,gGAKvB,SAAUV,EAASiB,EAAqBC,GAAxC,gEACE,OADF,SACQ,CAACd,KAAM,QAASc,UAASD,QADjC,8EAIA,SAAUhB,EAAkBgB,GAA5B,gEACE,uBAAOjB,EACZiB,EADiB,6BAEKE,KAAKC,UAAUH,EAAM,KAAM,KAF5C,QADF,4EAOP,SAASI,EAAiBC,EAAkBC,GAC1C,IAAMV,EAASS,EAAWE,KAAKD,GAE/B,GAAIV,EAAOY,KACT,MAAO,CACLrB,KAAM,UACNF,MAAOW,EAAOX,OAIlB,IAAMwB,EAA6B,WACjC,OAAQb,EAAOX,MAAME,MACnB,IAAK,MAKH,OCzED,SAAkBuB,GACvB,OAAOA,EAAQtB,OACb,SAACE,EAAqBM,GACpB,OAAQN,EAAYH,MAClB,IAAK,QACH,OAAQS,EAAOT,MACb,IAAK,QACH,MAAO,CACLA,KAAM,QACNwB,OAAO,GAAD,mBAAMrB,EAAYqB,QAAlB,YAA6Bf,EAAOe,UAE9C,IAAK,UACH,MAAO,CACLxB,KAAM,QACNwB,OAAQrB,EAAYqB,QAGxB,QACE,OAAOf,EAEb,IAAK,UACH,OAAQA,EAAOT,MACb,IAAK,QACH,MAAO,CACLA,KAAM,QACNwB,OAAQf,EAAOe,QAEnB,IAAK,UACH,MAAO,CACLxB,KAAM,UACNF,MAAM,GAAD,mBAAMK,EAAYL,OAAlB,CAAyBW,EAAOX,SAGzC,QACE,OAAOW,EAGb,QACE,OAAON,IAGb,CAACH,KAAM,UAAWF,MAAO,KDgCd2B,CAJShB,EAAOX,MAAMC,YAAY2B,IAAI,SAAAR,GAAU,OACrDD,EAAcC,MAKlB,IAAK,QAMH,MAAO,CAAClB,KAAM,QAASwB,OAAQ,CALjB,CACZG,SAAUlB,EAAOX,MAAMe,KAAKe,IAC5Bd,QAASL,EAAOX,MAAMgB,WAM1B,QACE,OAAOL,EAAOX,OAnBe,GAuBnC,OAAQwB,EAAWtB,MACjB,IAAK,QACH,OAAOsB,EACT,IAAK,UACH,OAAOL,EAAcC,EAAYI,EAAWxB,OAE9C,QACE,OAAOwB,G,MErFTO,IAAIC,SAfNC,E,EAAAA,OACAC,E,EAAAA,MACAC,E,EAAAA,SACAC,E,EAAAA,OACAC,E,EAAAA,KACAC,E,EAAAA,KACAC,E,EAAAA,SAaK,SAASC,EAAMC,EAAqBV,GACzC,OAAOU,EAAaP,EAAMD,EAAO,CAAC,IAAKF,EAAK,OAASA,E,WC1BjDW,EAAwC,CAC5CC,MAAO,UAGF,SAASC,EAAQC,GAA0C,IACzDC,EAAQD,EAARC,KAEP,OAAOJ,EAAYI,IAASA,ECRvB,SAASrC,EAAgBL,EAAYM,GAC1C,OAAON,EAAMD,OAAO,SAACE,EAAkBG,GACrC,IAAMG,EAASD,EAAEF,GAEjB,OAAOG,EAAM,sBAAON,GAAP,CAAoBM,IAAUN,GAC1C,I,eCoBY0C,G,WA2BAC,G,WAsBAC,G,WAkMAL,IAnPV,SAAUG,EAAiBG,GAA3B,qEACGA,EAAIhD,KADP,OAEE,eAFF,OAIE,kBAJF,+CAGMiD,EAAmBD,IAHzB,gCAKMA,EAAIlD,OALV,OAOM,uBAAOoD,EAAoBF,EAAK,iCAAhC,QAPN,4EAWP,SAASG,EACPC,GAEA,OAAQA,EAAGpD,MACT,IAAK,aACH,OAAOiD,EAAmBG,GAC5B,IAAK,0BACH,MAAM,GAAN,OAAUD,EACRC,EAAGC,eADL,YAEKJ,EAAmBG,EAAGA,KAE7B,QACE,OAAOA,GAIN,SAAUN,EAAkBQ,GAA5B,qEACGA,EAAItD,KADP,OAEE,0BAFF,+CAGMmD,EAA2CG,EAAIF,KAHrD,OAKM,uBAAOF,EAAoBI,EAAK,8BAAhC,QALN,4EAsBA,SAAUP,EACfO,GADK,qEAGGA,EAAItD,KAHP,OAIE,sBAJF,OASE,wBATF,OAkBE,iCAlBF,QAuBE,0BAvBF,QAgCE,wBAhCF,QAyCE,yBAzCF,QAgDE,2BAhDF,QA8DE,0BA9DF,QAuEE,4BAvEF,QA4EE,+BA5EF,QAiFE,wBAjFF,QAsFE,2BAtFF,QA+FE,8BA/FF,QAwGE,gCAxGF,QA6GE,yBA7GF,QAsHE,yBAtHF,QAuIE,gCAvIF,QA4IE,yBA5IF,QAqJE,uBArJF,QA0JE,wBA1JF,QAyKE,yBAzKF,QA8KE,wBA9KF,QAmLE,uBAnLF,wBAKM,uBAAOkD,EACZI,EACA,iCAFK,QALN,6CAeY,uBAAOZ,GAAQY,EAAIC,aAAnB,QAfZ,0CAaGvD,KAAM,WACN4C,KAAM,OACNY,OAfH,yBAWCxD,KAAM,WACNsD,IAZD,eAmBM,uBAAOJ,EACZI,EACA,6CAFK,SAnBN,wEAwBM,CACLtD,KAAM,WACNsD,IAAK,CACHtD,KAAM,WACN4C,KAAM,OACNY,OAAQ,MA7BX,iCAiCM,CACLxD,KAAM,WACNsD,IAAK,CACHtD,KAAM,WACN4C,KAAM,YACNY,OAAQ,MAtCX,iCA0CM,CACLxD,KAAM,WACNsD,IAAK,CACHtD,KAAM,cA7CT,QAqDW,uBAAOkD,EACbI,EAAIE,OAAO9B,IAAI,mBAAsBgB,GAAtB,EAAEe,mBADX,SArDX,QAwDc,OAxDd,UAwDc,gBAAOf,GAAQY,EAAII,YAAnB,SAxDd,gCAyDcJ,EAAIK,eACXC,EAAeN,EAAIK,eAAeH,OAAQ,SAAAK,GAAK,OAAIA,EAAMjB,OACzD,GA3DP,OAoDG5C,KAAM,WACNwD,OArDH,KAwDGM,UAxDH,MAyDGC,UAzDH,0BAkDC/D,KAAM,WACNsD,IAnDD,yCA+DM,CACLtD,KAAM,WACNsD,IAAK,CACHtD,KAAM,WACN4C,KAAMO,EAA2CG,EAAIF,IACrDI,OAAQ,MApEX,QAwEM,uBAAON,EACZI,EACA,mCAFK,UAxEN,gDA6EM,uBAAOJ,EACZI,EACA,sCAFK,UA7EN,gDAkFM,uBAAOJ,EACZI,EACA,mCAFK,UAlFN,gDA4FY,uBAAOZ,GAAQY,EAAIG,gBAAnB,UA5FZ,gDA0FGzD,KAAM,WACN4C,KAAM,SACNY,OA5FH,0BAwFCxD,KAAM,WACNsD,IAzFD,yCAgGM,CACLtD,KAAM,WACNsD,IAAK,CACHtD,KAAM,WACN4C,KAAM,OACNY,OAAQ,MArGX,QAyGM,uBAAON,EACZI,EACA,4CAFK,UAzGN,yEA8GM,CACLtD,KAAM,WACNsD,IAAK,CACHtD,KAAM,WACN4C,KAAM,IACNY,OAAQ,MAnHX,WAuH6B,IAA1BF,EAAIU,WAAWC,OAvHlB,0CAwHQ,CACLjE,KAAM,WACNsD,IAAK,CACHtD,KAAM,WACN4C,KAAM,OACNY,OAAQ,MA7Hb,yCAwIM,CACLxD,KAAM,OACNsD,QA1ID,iCA6IM,CACLtD,KAAM,WACNsD,IAAK,CACHtD,KAAM,WACN4C,KAAM,SACNY,OAAQ,MAlJX,QAsJM,uBAAON,EACZI,EACA,kCAFK,UAtJN,mDA2JwB,IAArBA,EAAIY,MAAMD,OA3Jb,iBA4JQ,uBAAOf,EACZI,EACA,wDAFK,UA5JR,gDAsKW,uBAAOJ,EAAUI,EAAIY,MAAMxC,IAAI,SAAA4B,GAAG,OAAIZ,GAAQY,MAA9C,UAtKX,kCAqKGtD,KAAM,QACNwD,OAtKH,0BAmKCxD,KAAM,WACNsD,IApKD,gBA0KM,uBAAOJ,EACZI,EACA,8DAFK,UA1KN,yEA+KM,CACLtD,KAAM,OACNsD,QAjLD,iCAoLM,CACLtD,KAAM,WACNsD,IAAK,CACHtD,KAAM,WACN4C,KAAM,OACNY,OAAQ,MAzLX,iCA8LMF,GA9LN,uCAkMA,SAAUZ,GAAQY,GAAlB,sEACe,uBAAOP,EAAkBO,GAAzB,QADf,OACCa,EADD,UAGGA,EAAYnE,KAHf,OAIE,aAJF,OAME,SANF,gDAKMmE,EAAYb,KALlB,YAOOa,EAAYb,IAAItD,KAPvB,OAQM,yBARN,OAaM,gCAbN,QAkBM,wBAlBN,wBASU,uBAAOkD,EACZiB,EAAYb,IACZ,uEAFK,SATV,+CAcU,uBAAOJ,EACZiB,EAAYb,IACZ,oEAFK,SAdV,+CAmBU,uBAAOJ,EACZiB,EAAYb,IACZ,2DAFK,SAnBV,wEAyBUa,EAAYb,KAzBtB,iCA6BMa,GA7BN,uCAiCA,SAASC,GAAkBC,GAChC,OAAOC,EACLA,EAAW,CACT,IACAA,EACEA,EAAW,CACTA,EACAA,EAASA,EAAUD,GACnBC,EACAA,EAAUA,EAAW,CAAC,IAAKA,EAAU,aAGzCA,EACA,OAKC,SAASC,GAAMhC,EAAqBe,GACzC,OAAQA,EAAItD,MACV,IAAK,WACH,OAAOsE,EACL/B,EACA+B,EACEA,EAAA,sBAC+B,IAAzBhB,EAAIS,UAAUE,OACd,CACEK,EACEA,EAAW,CACT,SACAA,EACA,IACAA,EACEA,EACEA,EAAA,CACEA,GADF,mBAEKhB,EAAIS,UAAUrC,IAAI,SAAA8C,GAAQ,OAC3BF,EAAW,CAACE,EAAUF,OAH1B,CAKEA,EAAUA,EAAW,CAAC,IAAKA,EAAU,eAI3CA,EACA,IACA,IACAA,MAIN,IA1BN,YA2BKhB,EAAIE,OAAO9B,IAAI,SAAAmC,GAAK,OACrBS,EACEA,EAAW,CAACC,IAAM,EAAMV,GAAQS,EAAU,KAAMA,QA7BtD,CAgCEC,IAAM,EAAMjB,EAAIQ,gBAIxB,IAAK,WACH,MAAO,IACT,IAAK,QACH,OAAQR,EAAIE,OAAOS,QACjB,KAAK,EACH,MAAO,OACT,QACE,OAAOK,EACL/B,EACA+B,EACEA,EACEA,EAAW,CAACA,EAAU,IAAKA,IAC3BhB,EAAIE,OAAO9B,IAAI,SAAAmC,GAAK,OAAIU,IAAM,EAAMV,QAKhD,IAAK,WACH,OAAOS,EACL/B,GAAoC,IAAtBe,EAAIE,OAAOS,OACzBK,EACEA,EAAW,CACThB,EAAIV,KACJ0B,EACEA,EACEhB,EAAIE,OAAO9B,IAAI,SAAAmC,GAAK,OAClBS,EAAW,CAACA,EAAUC,IAAM,EAAMV,aAQhD,QACE,OAAOP,G,gBC/PHmB,I,YAMAC,I,YAmCAC,I,YA0CAC,I,YAgDAC,I,YAmEOC,I,YA6KAC,I,YAsCArC,IA9ZJsC,GAAQ,CACnBhF,KAAM,WACN4C,KAAM,MAGR,SAAU6B,GACRQ,GADF,gEAGS,uBAAOC,EAAqBD,EAASjC,KAArC,QAHT,6EAMA,SAAU0B,GACRS,GADF,gEAGS,uBAAOjC,EACZiC,EAAQnB,WAAWtC,IAAnB,SAAuB,WAAUuD,GAAV,2EACbA,EAASjF,KADI,OAEd,mBAFc,OAkBd,gBAlBc,6BAGTiF,EAASnF,MAAME,KAHN,OAIV,eAJU,uBAQL,OAHDF,EAASmF,EAATnF,MAGC,gBAAO2E,GAAsBQ,GAA7B,QARK,6BASDhC,EAAmBnD,GATlB,mBAQX8C,KARW,KASXwC,SATW,eAaN,uBAAOlC,EACZ+B,EAASnF,MACT,0BAFK,SAbM,+CAmBV,uBAAOoD,EACZ+B,EACA,mDAFK,SAnBU,wEAyBVA,GAzBU,2CADlB,QAHT,6EAmCA,SAAUN,GAAYU,GAAtB,6EACUA,EAAKrF,KADf,OAES,iBAFT,OAKS,sBALT,OAUS,eAVT,OAgBS,qBAhBT,OAkBS,kBAlBT,QAkCS,gBAlCT,wBAGa,uBAAOkD,EAAuBmC,EAAM,4BAApC,QAHb,6CAMa,uBAAOnC,EACZmC,EACA,kCAFK,QANb,sEAWa,CACLrF,KAAM,WACN4C,KAAMK,EAAmBoC,KAbjC,OAiBa,uBAAOnC,EAAuBmC,EAAM,4BAApC,QAjBb,kDAmBsBA,EAAK5B,eAnB3B,iBAoBU,uBAAOyB,EAAsBG,EAAK5B,eAAeA,gBAAjD,SApBV,0CAqBU,uBAAOP,EACLmC,EACA,uDAFF,SArBV,0BAyBqB,OANTC,EAnBZ,KAyBqB,gBAAOZ,GAAyBW,GAAhC,SAzBrB,eAyBYE,EAzBZ,uBA2Ba,CACLvF,KAAM,SACNuF,SACAC,OAAQF,IA9BhB,QAmCa,uBAAOpC,EAAuBmC,EAAM,4BAApC,SAnCb,wEAsCaA,GAtCb,wCA0CA,SAAUT,GACR1D,GADF,qEAGUA,EAAWlB,KAHrB,OAIS,kBAJT,+CAKakB,EAAWpB,OALxB,OAOa,uBAAOoD,EACZhC,EACA,6BAFK,QAPb,6EAcA,SAASuE,GAAqBC,GAC5B,GAAIA,EAAWzB,QAAU,EAAG,CAC1B,IAAM0B,EAAYD,EAAW,GAC7B,OAAQC,EAAU3F,MAChB,IAAK,iBACH,OAAOyF,GAAqBE,EAAUC,MACxC,IAAK,kBACH,GAAID,EAAUE,SACZ,OAAQF,EAAUE,SAAS7F,MACzB,IAAK,qBACH,OAAQ2F,EAAUE,SAASpC,eAAeA,eAAezD,MACvD,IAAK,sBACH,OAAO,EACT,QACE,OAAO,EAEb,QACE,OAAO,EAGb,OAAO,EACT,QACE,OAAO,GAIb,OAAO,EAQT,SAAU6E,GACRa,EACAI,GAFF,+EAIQC,EAAkB,CAACR,OAAQ,GAAIS,mBAAoBN,GAE/B,IAAtBA,EAAWzB,OANjB,yCAOW8B,GAPX,OAUQE,EAAgBP,EAAW,GAVnC,KAYUO,EAAcjG,KAZxB,OAaS,mBAbT,OAkBS,wBAlBT,uBAca,uBAAO6E,GAAwC,GAAD,mBAC/CoB,EAAcL,MADiC,YACxBF,EAAWQ,MAAM,KAC5CJ,GAFK,QAdb,gDAmBgD,IAAtCG,EAAcE,aAAalC,OAnBrC,iBAoBe,uBAAOf,EACZ+C,EACA,4CAFK,SApBf,oDA0BYG,EAAcH,EAAcE,aAAa,IAE/BE,KA5BtB,sBA6BgBD,EAAYC,KAAKrG,KA7BjC,OA8Be,eA9Bf,4BA+B2BoG,EAAYC,KAApBzD,OAEMkD,EAjCzB,sBAkCsBM,EAAYhD,GAAGpD,KAlCrC,OAmCqB,kBAnCrB,yBAoCiC,uBAAO0E,GACpB0B,EAAYhD,IADC,SApCjC,eAoCwBmC,EApCxB,uBAwCyB,CACLA,SACAS,mBAAoBN,EAAWQ,MAAM,KA1CzD,QA8CyB,uBAAOhD,EACZkD,EAAYhD,GACZ,wDAFK,SA9CzB,gGA+Da2C,GA/Db,wCAmEO,SAAUjB,GACfY,GADK,iGAGqB,IAAtBA,EAAWzB,OAHV,yCAIIe,IAJJ,OAOCW,EAAYD,EAAW,GAPxB,KASGC,EAAU3F,KATb,OAUE,mBAVF,OAeE,oBAfF,OAiBE,oBAjBF,QAkJE,wBAlJF,wBAWM,uBAAO8E,GAAkB,GAAD,mBAC1Ba,EAAUC,MADgB,YAE1BF,EAAWQ,MAAM,MAFf,QAXN,iDAgBMP,EAAUE,SAhBhB,iBAgB2B,uBAAOnD,GAAQiD,EAAUE,UAAzB,SAhB3B,+CAgBgEb,GAhBhE,kDAkBMsB,EAAuBX,EAAvBW,aAAcC,EAASZ,EAATY,OAEnBD,EAAaE,kBAC4B,IAAzCF,EAAaE,iBAAiBvC,OArB/B,sBAsBKqC,EAAaE,iBAAiB,GAAG1G,MAAM2G,OAtB5C,wBAuBK,uBAAOvD,EACLoD,EACA,2EAFF,SAvBL,0BAmBKI,EAnBL,UA4BOJ,EAAatG,KA5BpB,OA8BM,qBA9BN,yBA+BiB,uBAAOkF,EAAqBoB,EAAarB,UAAzC,SA/BjB,WAiCiB,SAjCjB,sBAkCY,uBAAO/B,EACZoD,EAAarB,SACb,oEAFK,SAlCZ,+CAwCS/D,EAAaoF,EAAaK,OAxCnC,KA0CWzF,EAAWlB,KA1CtB,OA2CU,eA3CV,yBA6CwB,OADX8F,EAAmB5E,EAAW0B,KACnB,gBAAOM,EAAgBqD,EAAhB,SAAuB,+FAC7CK,EAD6C,EAC7CA,WACAC,EAF6C,EAE7CA,KAF6C,yCAKpC,MALoC,OAWzC,uBAAOhC,GACT+B,EACAd,GAFE,QAXyC,OAiBrC,OAjBqC,OAS3CP,EAT2C,EAS3CA,OACAS,EAV2C,EAU3CA,mBAOM,gBAAOlB,GAAkBkB,GAAzB,QAjBqC,OAmBrC,OAnBqC,eAkB3CT,EACM,gBAAOX,GAAyBiC,GAAhC,SAnBqC,4CAiB3CjB,KAjB2C,KAkB3CL,OAlB2C,KAmB3C3C,KAnB2C,iDAA9B,UA7CxB,WA6CakE,EA7Cb,MAmEaC,EACJR,EAAMS,KACJ,SAAAC,GAAM,OACHA,EAAOJ,OAASpB,GAAqBwB,EAAOL,eAC5C,KAvEd,MA2ESE,EA3ET,MA6EWC,GA7EX,uBA8EY,uBAAOjC,GAAkBiC,EAAYH,YAArC,UA9EZ,4BA+EuB,OA/EvB,YA+EuB,gBAAOlE,GAAQxB,GAAf,UA/EvB,iCAgFcwF,EAhFd,mBA0ES1G,KAAM,cACN8G,SA3ET,MA4ESI,cA5ET,MA+ESZ,aA/ET,MAgFSa,IAhFT,gBAoFc,uBAAOjE,EACZhC,EACA,gEAFK,UApFd,gDA4FwC,uBAAOgC,EAM1CqD,EAAO,CAACa,iBAAkB,GAAIN,SAAU,IANE,SAMG,aAE7CG,GAF6C,+EAC5CG,EAD4C,EAC5CA,iBAAkBN,EAD0B,EAC1BA,SAGdG,EAAOJ,KAJiC,yCAKpC,CAACO,iBAAkB,GAAIN,aALa,OAQhC,uBAAOlC,GAAyBqC,EAAOJ,MAAvC,QARgC,UAQvCjE,EARuC,KASvCyE,EATuC,sBASTD,GATS,CASSxE,IAErB,IAA7BqE,EAAOL,WAAW3C,OAXuB,yCAYpC,CAACmD,iBAAkBC,EAAyBP,aAZR,OAoBjC,OApBiC,KAgBzB,GAhByB,yBAkBtCA,GAEK,gBAAOhC,GAAkBmC,EAAOL,YAAhC,SApBiC,8BAqBhCS,EArBgC,MAoBvCzB,KApBuC,KAqBvCvB,MArBuC,2EAgB3C+C,iBAhB2C,KAiB3CN,SAjB2C,iDANV,UA5FxC,mBA4FUM,EA5FV,EA4FUA,iBAAkBN,EA5F5B,EA4F4BA,SAgCnBC,EACJR,EAAMS,KACJ,SAAAC,GAAM,OACHA,EAAOJ,OAASpB,GAAqBwB,EAAOL,eAC5C,KAhIV,4BAqIUE,GArIV,YAsIuC,IAA5BM,EAAiBnD,OACjB,CAAC,CAAC2B,KAAMZ,GAAIX,MAAO+C,IACnB,KAxIX,MA2IOL,GA3IP,uBA2IuB,uBAAOjC,GAAkBiC,EAAYH,YAArC,UA3IvB,4BA4ImB,OA5InB,YA4ImB,gBAAOlE,GAAQ4D,GAAf,UA5InB,iCA6IcI,EA7Id,mBAmIK1G,KAAM,eACN8G,SApIL,MA0IKI,cA1IL,MA4IKZ,aA5IL,MA6IKhB,QA7IL,mBAmJqC,IAAlCK,EAAUQ,aAAalC,OAnJ1B,iBAoJQ,uBAAOf,EACZyC,EACA,mCAFK,UApJR,gDA8JO,OAJFS,EAAcT,EAAUQ,aAAa,GAInC,gBAAOrB,GAAkBY,EAAWQ,MAAM,IAA1C,UA9JP,QA+JO,OA/JP,YA+JO,gBAAOvB,GAAYyB,EAAYhD,IAA/B,UA/JP,wBAgKQgD,EAAYC,KAhKpB,iBAiKK,uBAAO3D,GAAQ0D,EAAYC,MAA3B,UAjKL,4CAkKK,uBAAOnD,EACLkD,EACA,sCAFF,UAlKL,kEA6JCpG,KAAM,MACN4F,KA9JD,MA+JCP,KA/JD,MAgKCvF,MAhKD,gBAyKM,uBAAOoD,EAAwByC,GAA/B,UAzKN,gFA6KA,SAAUZ,GACfuC,GADK,sEASQ,OAHPxD,EAAYwD,EAAI5D,WAAa4D,EAAI5D,WAAWD,eAAiB,KAGtD,gBAAOP,EAChBoE,EAAI9D,OAAO9B,IAAX,SAAe,WAAUmC,GAAV,qEACLA,EAAM7D,KADD,OAEN,eAFM,+BAID6D,EAAMjB,MACPiB,EAAMJ,eALJ,gBAMH,uBAAOyB,GAAYrB,EAAMJ,eAAeA,gBAAxC,QANG,6CAOH,KAPG,4CAIPb,KAJO,KAKPU,IALO,eAUF,uBAAOJ,EACZW,EACA,oDAFK,SAVE,kFADN,QATR,oBA4BiB,mBAAlByD,EAAI1B,KAAK5F,KA5BR,gBA6BG,uBAAO8E,GAAkBwC,EAAI1B,KAAKA,MAAlC,QA7BH,wCA8BG,uBAAOlD,GAAQ4E,EAAI1B,MAAnB,QA9BH,2CA+BQ9B,GA/BR,sBA+BsB,uBAAOoB,GAAYpB,GAAnB,SA/BtB,gDAgCYwD,EAAI3D,eACfC,EAAe0D,EAAI3D,eAAeH,OAAQ,SAAAK,GAAK,OAAIA,EAAMjB,OACzD,GAlCD,mBASH2E,UATG,KA2BH3B,KA3BG,KA+BH9B,UA/BG,KAgCH0D,cAhCG,+CAsCA,SAAU9E,GAAQxB,GAAlB,iGACGA,EAAWlB,KADd,OAEE,oBAFF,OA+BE,4BA/BF,QAoCE,qBApCF,QA2CE,mBA3CF,QAgDE,mBAhDF,QAuEE,0BAvEF,QA8EE,uBA9EF,QAmFE,eAnFF,QAwFE,sBAxFF,QA+FE,qBA/FF,QAsHE,gBAtHF,QAwHE,mBAxHF,QA6HE,qBA7HF,QAwIE,4BAxIF,QA0IE,kBA1IF,QA+IE,uBA/IF,QA+QE,oBA/QF,8BAKWkB,EAAWuG,SALtB,gBAMK,uBAAOvE,EACLhC,EAAWuG,SAAS/F,IAApB,SAAwB,WAAUpB,GAAV,mEACjBA,EADiB,gBAEb,uBAAO4C,EACZhC,EACA,4CAFK,QAFa,gDAQD,kBAAjBZ,EAAQN,KARU,gBASb,uBAAOkD,EACZ5C,EACA,qCAFK,QATa,6CAef,uBAAOoC,GAAQpC,GAAf,QAfe,gFAD1B,QANL,wCA0BK,uBAAO4C,EACLhC,EACA,qCAFF,QA1BL,6DAIClB,KAAM,kBACNyH,SALD,eAkCQ,uBAAO1C,GAAW7D,GAAlB,SAlCR,4CAiCClB,KAAM,qBACNF,MAlCD,eAuCO,uBAAO4C,GAAQxB,EAAWwG,MAA1B,SAvCP,QAyCQ,OAzCR,eAwCWxG,EAAWyG,SACd,gBAAOjF,GAAQxB,EAAW0G,OAA1B,UAzCR,8CAsCC5H,KAAM,mBACN0H,KAvCD,KAwCCC,SAxCD,KAyCCC,MAzCD,yCA4CM,CACL5H,KAAM,WACNF,MAAOoB,EAAWpB,QA9CnB,QAmDY,uBAAOoD,EAChBhC,EAAWqG,UAAU7F,IAArB,SAAyB,WAAUmE,GAAV,qEACfA,EAAS7F,KADM,OAEhB,wBAFgB,OAOhB,kBAPgB,sBAGZ,uBAAOkD,EACZ2C,EACA,iCAFK,QAHY,6CAQZ,uBAAO3C,EACZ2C,EACA,+BAFK,QARY,6CAaZ,uBAAOnD,GAAQmD,GAAf,QAbY,gFADhB,UAnDZ,QAqES,OArET,YAqES,gBAAOnD,GAAQxB,EAAW2G,QAA1B,UArET,8CAkDC7H,KAAM,iBACNuH,UAnDD,MAqECM,OArED,gBA0EY,uBAAOnF,GAAQxB,EAAW4G,WAA1B,UA1EZ,QA2Ea,OA3Eb,YA2Ea,gBAAOpF,GAAQxB,EAAW0F,YAA1B,UA3Eb,QA4EO,OA5EP,YA4EO,gBAAOlE,GAAQxB,EAAW2F,MAA1B,UA5EP,8CAyEC7G,KAAM,wBACN8H,UA1ED,MA2EClB,WA3ED,MA4ECC,KA5ED,gBAiFQ,uBAAO9B,GAAW7D,GAAlB,UAjFR,8CAgFClB,KAAM,qBACNF,MAjFD,yCAoFM,CACLE,KAAM,WACN4C,KAAM1B,EAAW0B,OAtFlB,QA2FO,uBAAOF,GAAQxB,EAAWwG,MAA1B,UA3FP,QA6FQ,OA7FR,kBA4FWxG,EAAWyG,SACd,gBAAOjF,GAAQxB,EAAW0G,OAA1B,UA7FR,8CA0FC5H,KAAM,mBACN0H,KA3FD,MA4FCC,SA5FD,MA6FCC,MA7FD,sBAgGO1G,EAAWyF,OAAO3G,KAhGzB,OAiGM,uBAjGN,0BAmGkB,OAnGlB,EAkGgDkB,EAAWyF,OAArCA,EAlGtB,EAkGUzF,WAAoBuC,EAlG9B,EAkG8BA,eACZ,gBAAOyB,EACpBzB,EAAeA,gBADF,UAnGlB,QAsGiB,OAHR+B,EAnGT,MAsGiB,gBAAON,EAAqBhE,EAAW+D,UAAvC,UAtGjB,QA2Ga,OALJ8C,EAtGT,YA0GKA,EACQ,gBAAOrF,GAAQiE,GAAf,UA3Gb,iCA4GKnB,EA5GL,mBAyGKxF,KAAM,mBACN+H,MA1GL,MA2GKpB,OA3GL,MA4GKnB,OA5GL,gBAgHU,uBAAOtC,EACZhC,EAAWyF,OACX,gEAFK,UAhHV,yEAuHM3B,IAvHN,iCAyHM,CACLhF,KAAM,WACNF,MAAOoB,EAAWpB,QA3HnB,WA8HoC,IAAjCoB,EAAW8C,WAAWC,OA9HzB,0CA+HQe,IA/HR,QAkIM,uBAAO9B,EACZhC,EACA,uDAFK,UAlIN,gDAyIM,uBAAOwB,GAAQxB,EAAWA,YAA1B,UAzIN,yEA2IM,CACLlB,KAAM,WACNF,MAAOoB,EAAWpB,QA7InB,cAgJOoB,EAAWA,WAAWlB,KAhJ7B,OAiJM,qBAjJN,SA0PM,kBA1PN,0BAkJoC,uBAAOkD,EACtChC,EAAWA,WAAW8C,WACrB,CAAC,GAAI,GAAI,IAF4B,SAGtC,aAAoCiB,GAApC,mGAAWZ,EAAX,KAAkBkB,EAAlB,KAA0ByC,EAA1B,UACU/C,EAASjF,KADnB,OAES,iBAFT,OAOS,mBAPT,OAkCS,kBAlCT,wBAGa,uBAAOkD,EACZ+B,EACA,8BAFK,QAHb,iDAQUA,EAASgD,SARnB,gBASe,uBAAO/E,EACZ+B,EAASjC,IACT,oCAFK,QATf,6CAemB,uBAAOyB,GAAsBQ,GAA7B,SAfnB,WAeYrC,EAfZ,KAkBY9C,EAA8BmF,EAASnF,MAEhC,SAAT8C,EApBV,iBAsBqB,OAtBrB,yBAsBcyB,GAAO,gBAAOO,GAAyB9E,GAAhC,SAtBrB,iFAuBUyF,EAvBV,MAwBUyC,EAxBV,8CA8BkC,OA9BlC,MA6BQ3D,EA7BR,2BA8BYkB,GA9BZ,MA8BqB3C,EAAa,gBAAOF,GAAQ5C,GAAf,UA9BlC,kCA8BqB8C,KA9BrB,MA8B2B9C,MA9B3B,sEA+BQkI,EA/BR,kDAmC2B,IAAjB3D,EAAMJ,QAAkC,IAAlBsB,EAAOtB,OAnCvC,iBAoCQ,uBAAOf,EACL+B,EACA,0DAFF,UApCR,QA6CqB,OA7CrB,MA2CQZ,EA3CR,MA4CQkB,EA5CR,2BA6CYyC,GAAS,gBAAOtF,GAAQuC,EAASY,UAAxB,UA7CrB,4JAiDaZ,GAjDb,0CAH+B,UAlJpC,QA0MmB,OA1MnB,2BAkJUZ,EAlJV,KAkJiBkB,EAlJjB,KAkJyByC,EAlJzB,KA0MmB,gBAAO9C,EACrBhE,EAAWuC,eAAeA,gBADZ,UA1MnB,WA0MS6B,EA1MT,QA8MOjB,EAAMJ,QAAU,GA9MvB,iBA+MY,uBAAOf,EACZhC,EAAWA,WACX,oCAFK,UA/MZ,qDAoNO8G,EAAQ/D,QAAU,GApNzB,iBAqNY,uBAAOf,EACZhC,EAAWA,WADC,kEAE+C8G,EAAQ/D,SAF9D,UArNZ,mDA2NwB,IAAjBI,EAAMJ,OA3Nb,oBA4N4B,IAAnB+D,EAAQ/D,OA5NjB,0CA6Nc,CAACjE,KAAM,iBAAkBwF,OAAQF,EAASC,WA7NxD,iCAgOYA,EAAOtF,OACZ,SAACE,EAAa4H,GAAd,MAAyB,CACvB/H,KAAM,eACN+H,MAAOA,EAAMnF,KACb+D,OAAQxG,EACRqF,OAAQF,EACR4C,OAAQH,EAAMjI,QAEhBkI,EAAQ,KAxOf,WA4O0B,IAAnBA,EAAQ/D,OA5Of,0CA6OY,CACLjE,KAAM,cACNmI,OAAQ9D,EAAM,GACdkB,SACA4B,IAAK7B,IAjPZ,QAqPU,uBAAOpC,EACZhC,EAAWA,WACX,gDAFK,UArPV,gDAgQc,OALJpB,EAASoB,EAAWA,WAApBpB,MA3PV,MA+PeA,EACD,gBAAOoF,EACdhE,EAAWuC,eAAeA,gBADnB,UAhQd,8CA8PKzD,KAAM,eACNoI,SA/PL,MAgQK9C,QAhQL,gBAwQiB,uBAAO5C,GAAQxB,EAAWA,YAA1B,UAxQjB,QAyQqB,OAzQrB,YAyQqB,gBAAOgE,GACrBhE,EAAWuC,eAAeA,gBADZ,WAzQrB,+CAuQKzD,KAAM,qBACNkB,WAxQL,MAyQKuC,eAzQL,iBAkRW,uBAAOf,GAAQxB,EAAW2E,UAA1B,WAlRX,kCAmRW3E,EAAWyG,SAnRtB,mBAiRC3H,KAAM,kBACN6F,SAlRD,MAmRC8B,SAnRD,iBAsRM,uBAAOzE,EAAwBhC,GAA/B,WAtRN,kFA0RA,SAASmH,GAAkBC,GAChC,OAAOhE,EACLgE,EAAa5G,IAAI,gBAAEkB,EAAF,EAAEA,KAAMU,EAAR,EAAQA,IAAR,OACfgB,EAAW,CACTA,EACAhB,EACIgB,EACEA,EAAW,CACT,IACA1B,EACA0B,EACA,IACAA,EACAY,IAAU,EAAO5B,GACjB,OAGJV,OAMZ,SAAS2F,GACPhG,EACAsF,EACAW,GAEA,OAAOlE,EACL/B,EACA+B,EAAUA,EAAWA,EAASA,EAAT,CAAoBuD,GAApB,mBAA+BW,QAIjD,SAASC,GACdjD,EACAD,GAEA,OAAOjB,EACLA,EAAW,CACT,KACAA,EACEA,EACEiB,EAAO7D,IAAI,gBAAEkB,EAAF,EAAEA,KAAM9C,EAAR,EAAQA,MAAR,OACTwE,EAAW,CACTA,EACAA,EACEA,EAAW,CACTA,EACEA,EAAW,CACTkB,EAAM,UAAMA,EAAN,YAAgB5C,GAASA,EAC/B0B,EACA,QAGJA,EAAWA,EAAW,CAACA,EAAUxE,EAAO,gBAOpDwE,EACA,QAKN,SAASoE,GAAerD,EAAiBsD,GACvC,OAAQtD,EAAKrF,MACX,IAAK,SACH,OAA2B,IAAvBqF,EAAKE,OAAOtB,OACP,IAGFK,EAAA,sBACDqE,EAAY,CAAC,KAAO,IADnB,CAELF,GACEpD,EAAKG,OACLH,EAAKE,OAAO7D,IAAI,kBAAuB,CAACkB,KAAxB,EAAEA,KAA4B9C,MAA9B,EAAQsF,gBAG9B,IAAK,WACH,OAAOC,EAAKzC,KAEd,QACE,OAAOyC,GAIb,SAASuD,GACPtC,EACAQ,EAOAI,EACA5B,GAEA,OAAOhB,EACLA,EAAA,CACEA,EACEA,EAAW,CAAC,QAASA,EAAUgC,EAAchC,EAAU,UAEzDA,GAJF,mBAKKwC,EAASpF,IAAI,gBAAEkE,EAAF,EAAEA,KAAMiD,EAAR,EAAQA,SAAR,OACdvE,EACEA,EAAW,CACTA,EACEA,EACAuE,EAASnH,IAAI,gBAAE6D,EAAF,EAAEA,OAAQ3C,EAAV,EAAUA,KAAV,OACX0B,EACEA,EAAA,CACE,IACAA,EAFF,UAGKgB,EAHL,YAGgB1C,IAHhB,mBAIM2C,EACA,CACEjB,EACAoE,GACE,CACE1I,KAAM,SACNuF,SACAC,OAAO,GAAD,OAAKF,EAAL,YAAgB1C,KAExB,IAGJ,UAKZ0B,EACA,KACAA,EAAWA,EAAW,CAACA,EAAUsB,KACjCtB,QApCR,YAwCM4C,EACA,CACE5C,EACEA,EAAW,CACTA,EAAUA,EAAW,CAAC,IAAKA,EAAU,IAAKA,EAAU,QACpDA,EAAWA,EAAW,CAACA,EAAU4C,KACjC5C,MAIN,IAlDN,CAmDE,UAKC,SAASC,GAAMhC,EAAqBrB,GACzC,OAAQA,EAAWlB,MACjB,IAAK,kBACH,OAAmC,IAA/BkB,EAAWuG,SAASxD,OACf,KAGFK,EACLA,EAAW,CACT,IACAA,EACEA,EAAW,CACTA,EACAA,EACEA,EAAW,CAAC,IAAKA,IACjBpD,EAAWuG,SAAS/F,IAAI,SAAApB,GAAO,OAAIiE,IAAM,EAAOjE,SAItDgE,EACA,OAGN,IAAK,mBACH,OAAOA,EACL/B,EACA+B,EACEA,EAASA,EAAU,CACjBC,IAAM,EAAMrD,EAAWwG,MACvBxG,EAAWyG,SACXpD,IAAM,EAAMrD,EAAW0G,WAI/B,IAAK,iBACH,OAAOW,GACLhG,EACAgC,IAAM,EAAMrD,EAAW2G,QACvB3G,EAAWqG,UAAU7F,IAAI,SAAAmE,GAAQ,OAAItB,IAAM,EAAMsB,MAErD,IAAK,wBACH,OAAOvB,EACL/B,EACA+B,EACEA,EAAW,CACTA,EACEA,EAAW,CACT,KACAA,EACAC,IAAM,EAAOrD,EAAW2F,MACxBvC,EACA,UAGJA,EACEA,EAAW,CAACA,EAAUC,IAAM,EAAOrD,EAAW0F,eAEhDtC,EACA,OACAA,EACEA,EAAW,CAACA,EAAUC,IAAM,EAAOrD,EAAW4G,kBAMxD,IAAK,WACH,OAAO/G,KAAKC,UAAUE,EAAWpB,OACnC,IAAK,eAAiB,IACbgH,EAAkD5F,EAAlD4F,SAAUI,EAAwChG,EAAxCgG,cAAeZ,EAAyBpF,EAAzBoF,aAAchB,EAAWpE,EAAXoE,QAE9C,OAAOsD,GACLrE,IAAM,EAAO+B,GACbQ,EAASpF,IAAI,gBAAEkE,EAAF,EAAEA,KAAMvB,EAAR,EAAQA,MAAR,MAAoB,CAC/BuB,KAAMrB,IAAM,EAAOqB,GACnBiD,SAAUxE,EAAM3C,IAAI,SAAAkB,GAAI,MAAK,CAAC2C,OAAQ,KAAM3C,aAE9CsE,GAAiB3C,IAAM,EAAO2C,GAC9B5B,GAGJ,IAAK,eACH,MAAM,GAAN,OAAUpE,EAAWoE,QAArB,YAAgCpE,EAAWkH,UAC7C,IAAK,qBACH,OAAO9D,EACL/B,EACA+B,EACEA,EAAW,CACTA,EACEA,EAAW,CACT,MACAA,EACEA,EAAA,sBACgD,IAA1CpD,EAAWpB,MAAM0H,cAAcvD,OAC/B,CACEK,EACAY,GAAsBhE,EAAWpB,MAAM0H,gBAEzC,IANN,CAOEa,GAAkBnH,EAAWpB,MAAMyH,eAGvCjD,EACA,QAGJA,EACEA,EAAW,CAACA,EAAUC,IAAM,EAAOrD,EAAWpB,MAAM8F,aAK9D,IAAK,MACH,OAAOtB,EACLA,EAAW,CACTA,EACEA,EAAW,CACT,MACAA,EACAoE,GAAexH,EAAWmE,MAAM,GAChCf,EACA,QAGJA,EAAWA,EAAW,CAACA,EAAUC,IAAM,EAAOrD,EAAWpB,UACzDwE,EACA,KACAA,EACAC,IAAM,EAAOrD,EAAW0E,SAG9B,IAAK,iBACH,OAAO6C,GACLvH,EAAWsE,OACXtE,EAAWqE,OAAO7D,IAAI,kBAAoB,CACxCkB,KADoB,EAAEA,KAEtB9C,MAAOyE,IAAM,EAFO,EAAQzE,WAKlC,IAAK,mBACH,OAAOwE,EACLA,EAAW,CACTC,IAAM,EAAMrD,EAAWyF,QACvBrC,EACA,KACAA,EACEA,EACEA,EAAW,CACTA,EACApD,EAAWsE,OACX,IACAtE,EAAW6G,UAIjBzD,EACA,OAGN,IAAK,eACH,OAAOiE,GACLhG,EADwB,UAErBrB,EAAWsE,OAFU,gBAEItE,EAAW6G,OACvC,CAACxD,IAAM,EAAMrD,EAAWyF,QAASpC,IAAM,EAAMrD,EAAWgH,UAE5D,IAAK,cAAgB,IACZpB,EAA8C5F,EAA9C4F,SAAUI,EAAoChG,EAApCgG,cAAeZ,EAAqBpF,EAArBoF,aAAca,EAAOjG,EAAPiG,IAE9C,OAAOyB,GACLrE,IAAM,EAAO+B,GACbQ,EAASpF,IAAI,gBAAEkE,EAAF,EAAEA,KAAML,EAAR,EAAQA,OAAQ3C,EAAhB,EAAgBA,KAAhB,MAA2B,CACtCgD,KAAMrB,IAAM,EAAOqB,GACnBiD,SAAU,CAAC,CAACtD,SAAQ3C,YAEtBsE,GAAiB3C,IAAM,EAAO2C,GAC9BC,GAGJ,IAAK,cACH,IAAMvE,EAAI,UAAM1B,EAAWiG,IAAjB,YAAwBjG,EAAWiH,QAE7C,OAAO7D,EACL/B,EACA+B,EACEA,EAAA,CACE1B,EACA0B,GAFF,mBAGmC,IAA7BpD,EAAWqE,OAAOtB,OAClB,CACEwE,GACE7F,EACA1B,EAAWqE,OAAO7D,IAAI,kBAAoB,CACxCkB,KADoB,EAAEA,KAEtB9C,MAAOyE,IAAM,EAFO,EAAQzE,YAMlC,CAAC,WAKb,IAAK,qBACH,OAAOwE,EACLA,EAAW,CACT,IACAA,EACAC,IAAM,EAAMrD,EAAWA,YACvBoD,EACA,IACAA,EACAY,IAAU,EAAOhE,EAAWuC,gBAC5Ba,EACA,OAGN,IAAK,kBACH,OAAOA,EACL/B,EACA+B,EACEA,EAAW,CACTpD,EAAWyG,SACXrD,EACAC,IAAM,EAAMrD,EAAW2E,cAI/B,IAAK,WACH,OAAO3E,EAAW0B,KAEpB,QACE,OAAO1B,G,gBC5qCH4H,I,YAMAC,I,YAWAC,I,YAqBAC,I,YA8DOvG,IApGjB,SAAUoG,GACR7D,GADF,gEAGS,uBAAOC,EAAqBD,EAASjC,KAArC,QAHT,6EAMA,SAAU+F,GACRzF,GADF,qEAGUA,EAAItD,KAHd,OAIS,gCAJT,+CAKasD,EAAIxD,OALjB,OAOa,uBAAOoD,EAAoBI,EAAK,6BAAhC,QAPb,6EAWA,SAAU0F,GAAkBE,GAA5B,sEACgB,uBAAOhG,EACnBgG,EAAKxH,IAAL,SAAS,WAAU4B,GAAV,qEACCA,EAAItD,KADL,OAEA,gCAFA,+CAGIsD,EAAIxD,OAHR,OAKI,uBAAOoD,EACZI,EACA,qCAFK,QALJ,gFADG,QADhB,cACQe,EADR,uBAeS,CACLrE,KAAM,OACNqE,UAjBJ,uCAqBA,SAAU4E,GAAeC,GAAzB,sEACuB,uBAAOhG,EAC1BgG,EAAKxH,IAAL,SAAS,WAAU4B,GAAV,iFACCA,EAAItD,KADL,OAEA,yBAFA,uBAGuC,uBAAOkD,EAC/CI,EAAIU,WACJ,CAAC,GAAI,IAF0C,SAG/C,aAA6CiB,GAA7C,kGAAWkE,EAAX,KAA2BC,EAA3B,KACwB,uBAAlBnE,EAASjF,KADf,gBAEW,uBAAOkD,EACZ+B,EACA,6BAFK,QAFX,6CAQe,uBAAO6D,GAA0B7D,GAAjC,QARf,cAQQrC,EARR,uBAUkB,SAATA,EACH,CAAC,GAAD,mBAAKuG,GAAL,CAAqBlE,IAAWmE,GAChC,CAACD,EAAD,sBAAqBC,GAArB,CAAsCnE,MAZ5C,yCAHwC,QAHvC,oCAGIkE,EAHJ,KAGoBC,EAHpB,KAsB2B,IAA1BD,EAAelF,OAtBhB,iBAuBM,uBAAOf,EACZI,EACA,oDAFK,SAvBN,+CA8BK,uBAAOyF,GACXI,EAAe,GAAGrJ,OADd,SA9BL,QAiCO,OAjCP,UAiCO,gBAAOoD,EACbkG,EAAgB1H,IAAhB,SAAoB,WAClBuD,GADkB,gEAIV,uBAAO6D,GAA0B7D,GAAjC,QAJU,OAKX,OALW,UAKX,gBAAOC,GAAYD,EAASnF,OAA5B,QALW,2CAIhB8C,KAJgB,KAKhBU,IALgB,iDADd,SAjCP,4CA8BDV,KA9BC,KAiCD2C,OAjCC,eA8CI,uBAAOrC,EACZI,EACA,yCAFK,SA9CJ,kFADU,QADvB,cACQ+F,EADR,uBAwDS,CACLrJ,KAAM,MACNqJ,iBA1DJ,uCA8DO,SAAU3G,GAAQY,GAAlB,0EACe,uBAAO4B,EAAsB5B,GAA7B,QADf,OACCa,EADD,UAGGA,EAAYnE,KAHf,OAIE,aAJF,OASE,SATF,gDAKM,CACLA,KAAM,UACNsD,IAAKa,EAAYb,MAPlB,YAUOa,EAAYb,IAAItD,KAVvB,OAWM,yBAXN,OAiDM,gCAjDN,QAmDM,wBAnDN,wBAa0B,OADjBsJ,EAAYnF,EAAYb,IACP,gBAAOJ,EAC5BoG,EAAUtF,WADkB,SAE5B,WAAUiB,GAAV,qEACUA,EAASjF,KADnB,OAES,uBAFT,sBAIS,uBAAO8I,GAA0B7D,GAAjC,QAJT,0CAIyD,SAJzD,uCAOa,GAPb,yCAFqB,SAb1B,kCA4BY,uBAAOgE,GAAe,CAACK,IAAvB,SA5BZ,+CA+BkB,uBAAOpG,EACpBoG,EAAUtF,WAAWtC,IAArB,SAAyB,WAAUuD,GAAV,mEACD,uBAAlBA,EAASjF,KADU,gBAEd,uBAAOkD,EAAY+B,EAAU,2BAA7B,QAFc,6CAMf,uBAAO6D,GAA0B7D,GAAjC,QANe,OAOhB,OAPgB,UAOhB,gBAAOC,GAAYD,EAASnF,OAA5B,QAPgB,2CAMrB8C,KANqB,KAOrBU,IAPqB,iDADZ,SA/BlB,eA+BSiC,EA/BT,uBA4CU,CACLvF,KAAM,SACNuF,WA9CL,QAkDU,uBAAOyD,GAAkB,CAAC7E,EAAYb,MAAtC,SAlDV,kDAqDwC,IAAjCa,EAAYb,IAAIY,MAAMD,OArD7B,0CAsDY,CACLjE,KAAM,UACNsD,IAAK,CACHtD,KAAM,WACN4C,KAAM,YACNY,OAAQ,MA3DjB,aAgEWW,EAAYb,IAAIY,MAAM,GAAGlE,KAhEpC,OAiEU,yBAjEV,QAmEU,gCAnEV,yBAkEc,uBAAOiJ,GAAe9E,EAAYb,IAAIY,OAAtC,SAlEd,+CAoEc,uBAAO8E,GAAkB7E,EAAYb,IAAIY,OAAzC,SApEd,+CAsEc,uBAAOhB,EACZiB,EAAYb,IACZ,gEAFK,UAtEd,yEA8EUa,EAAYb,KA9EtB,iCAkFMa,GAlFN,wCAsFP,SAASoF,GAAY3G,EAAcf,GACjC,OAAOyC,EACLA,EAAW,CACTA,EAAUA,EAAW,CAAC,SAAUA,EAAU1B,EAAM,OAChD0B,EAAWA,EAAW,CAACA,EAAczC,KACrCyC,EAAUA,EAAW,CAACA,EAAc,MAAOA,EAAU1B,EAAM,UAKjE,SAAS4G,GACP5G,EACA2C,EACAkE,GAEA,OAAOnF,EAAA,CACLA,EACEA,EAAW,CAAC,SAAUA,EAAU,IAAKA,EAAU,KAAMA,EAAU,OAEjEA,EACEA,EACEiB,EAAO7D,IAAI,gBAAEkB,EAAF,EAAEA,KAAMU,EAAR,EAAQA,IAAR,OACTgB,EAAW,CACTA,EACA1B,EACA0B,EACA,IACAA,EACAY,IAAU,EAAO5B,GACjBgB,EACA,UAKRA,EACA,MArBK,mBAsBDmF,EACA,CACEnF,EACAA,EACEA,EACAiB,EAAO7D,IAAI,gBAAEkB,EAAF,EAAEA,KAAF,EAAQU,IAAR,OACTgB,EACEA,EAAW,CACTA,EACEA,EAAW,CAAC,aAAcA,EAAf,cAAgC1B,MAE7C0B,EACEA,EACEA,EAAW,CACTA,EACA,IACAA,EACA1B,EACA0B,EACA,SAINA,EACEA,EAAW,CACTA,EACAoF,GACE,KACAnE,EAAO7D,IAAI,SAAAqG,GAAK,MAAK,CACnBnF,KAAMmF,EAAMnF,KACZ9C,MACEiI,EAAMnF,OAASA,EAAOA,EAAtB,aAAmCmF,EAAMnF,KAAzC,SAGN,cAQd,MAIR,SAAS+G,GAAwB/G,GAC/B,OAAO0B,EACLA,EAAW,CACT,aACAA,EACA1B,EACA0B,EACA,KACAA,EANS,UAON1B,EAPM,MAQT,O,gBC3RIgH,I,YAwCOlH,IAxCjB,SAAUkH,GACRvE,GADF,qEAGUA,EAAKrF,KAHf,OAIS,iBAJT,OAUS,sBAVT,OAeS,eAfT,OAkBS,qBAlBT,OAuBS,kBAvBT,QA6BS,gBA7BT,wBAKa,uBAAOkD,EACZmC,EACA,6EAFK,QALb,6CAWa,uBAAOnC,EACZmC,EACA,kCAFK,QAXb,sEAgBaA,GAhBb,OAmBa,uBAAOnC,EACZmC,EACA,gCAFK,QAnBb,8CAwBa,uBAAOnC,EACZmC,EACA,8EAFK,SAxBb,+CA8Ba,uBAAOnC,EACZmC,EACA,6CAFK,SA9Bb,wEAoCaA,GApCb,wCAwCO,SAAU3C,GAAQ0D,GAAlB,IAAAkB,EAAA,uEACGlB,EAAYpG,KADf,OAEE,mBAFF,OASE,mBATF,OAcE,qBAdF,OAqBE,sBArBF,OA0BE,sBA1BF,QA4BE,iBA5BF,QA6BE,gCA7BF,QA8BE,6BA9BF,QA+BE,oBA/BF,QAgCE,qBAhCF,QAiCE,kBAjCF,QAkCE,yBAlCF,QAmCE,sBAnCF,QAoCE,qBApCF,QAqCE,oBArCF,QAyCE,qBAzCF,QA8CE,mBA9CF,QAgDE,yBAhDF,QAkDE,6BAlDF,QAuDE,2BAvDF,QA8DE,wBA9DF,QAmEE,mBAnEF,QAwEE,mBAxEF,QA6EE,iBA7EF,QA+EE,wBA/EF,QAkGE,gBAlGF,QAuGE,sBAvGF,QAiHE,yBAjHF,QAsHE,qBAtHF,QA2HE,eA3HF,QAqIE,oBArIF,QA0IE,oBA1IF,QA+IE,mBA/IF,QAoJE,iBApJF,QAyJE,cAzJF,QAiKE,wBAjKF,QAwLE,mBAxLF,QA+LE,kBA/LF,wBAGM,uBAAOkD,EACZkD,EACA,uCAFK,QAHN,6CAUM,uBAAOlD,EACZkD,EACA,mCAFK,QAVN,6CAeM,uBAAOlD,EACZkD,EACA,sCAFK,QAfN,6CAsBM,uBAAOlD,EACZkD,EACA,sCAFK,SAtBN,gFAwCM,IAxCN,QA0CM,uBAAOlD,EACZkD,EACA,kCAFK,SA1CN,wEA+CM,IA/CN,QAiDM,uBAAOlD,EAAiBkD,EAAa,8BAArC,SAjDN,+CAmDM,uBAAOlD,EACZkD,EACA,iCAFK,SAnDN,mDAwDMA,EAAYA,YAxDlB,iBAyDG,uBAAO1D,GAAQ0D,EAAYA,aAA3B,SAzDH,0CA0DG,uBAAOlD,EACLkD,EACA,sCAFF,UA1DH,kEA+DM,uBAAOlD,EACZkD,EACA,yCAFK,UA/DN,gDAoEM,uBAAOlD,EACZkD,EACA,gCAFK,UApEN,gDAyEM,uBAAOlD,EACZkD,EACA,gCAFK,UAzEN,gDA8EM,uBAAOlD,EAAiBkD,EAAa,6BAArC,UA9EN,gDAgFW,uBAAOsD,GAAsBtD,GAA7B,UAhFX,WAgFKkB,EAhFL,OAiFYlB,EAAYhD,GAjFxB,uBAkFGgD,EAAYhD,GAAGR,KAlFlB,wBAqFG,uBAAOM,EAAoBkD,EAAa,2BAAxC,UArFH,mCAiFKxD,EAjFL,wBAuFM,CACL,CACE5C,KAAM,aACNuH,UAAWD,EAAIC,UACf3B,KAAM0B,EAAI1B,KACVhD,OACAkB,UAAWwD,EAAIxD,UACf0D,cAAeF,EAAIE,iBA9FtB,QAmGM,uBAAOtE,EACZkD,EACA,mCAFK,UAnGN,mDAwGgC,UAA7BA,EAAYyD,OAAO/J,MAxGtB,0CAyGQ,IAzGR,QA4GM,uBAAOoD,EACZkD,EACA,2CAFK,UA5GN,gDAkHM,uBAAOlD,EACZkD,EACA,0CAFK,UAlHN,gDAuHM,uBAAOlD,EACZkD,EACA,sCAFK,UAvHN,gDAgIkB,OAhIlB,MA+HSnD,EAAmBmD,EAAYhD,IACtB,gBAAO0G,GAAsB1D,EAAY2D,UAAzC,UAhIlB,kCA8HG/J,KAAM,iBACN4C,KA/HH,MAgIGoH,cAhIH,0CAsIM,uBAAO9G,EACZkD,EACA,oCAFK,UAtIN,gDA2IM,uBAAOlD,EACZkD,EACA,oCAFK,UA3IN,gDAgJM,uBAAOlD,EACZkD,EACA,oCAFK,UAhJN,gDAqJM,uBAAOlD,EACZkD,EACA,kCAFK,UArJN,gDA8JkB,OA9JlB,MA6JSnD,EAAmBmD,EAAYhD,IACtB,gBAAO0G,GAAsB1D,EAAYwB,OAAzC,UA9JlB,kCA4JG5H,KAAM,iBACN4C,KA7JH,MA8JGoH,cA9JH,0CAkKM,uBAAO9G,EACZkD,EAAYD,aAAazE,IAAzB,SAA6B,WAAU0E,GAAV,wEAChB,uBAAOwD,GAAwBxD,EAAYhD,IAA3C,QADgB,UACrBA,EADqB,KAErBU,EAAYV,EAAGK,eACjBL,EAAGK,eAAeA,eAClB,KAJuB,KAQd,IACL2C,EAAYC,KATO,gBAUrB,uBAAOqD,GAAmBtD,EAAYC,MAAtC,QAVqB,wCAWrB,uBAAOnD,EACLkD,EACA,uBAFF,SAXqB,4CAenBhD,EAAGR,KAfgB,KAgBdkB,GAhBc,sBAgBA,uBAAOoB,GAAYpB,GAAnB,SAhBA,iDAiBV,GAjBU,mBAOzB9D,KAAM,aACNuH,UARyB,KASzB3B,KATyB,KAezBhD,KAfyB,KAgBzBkB,UAhByB,KAiBzB0D,cAjByB,mDADxB,UAlKN,gDAyLM,uBAAOtE,EACZkD,EACA,+BAFK,UAzLN,gDAgMM,uBAAOlD,EACZkD,EACA,mCAFK,UAhMN,yEAsMMA,GAtMN,wCA0MA,SAAS7B,GAAM6B,GACpB,OAAQA,EAAYpG,MAClB,IAAK,aACH,OAAOsE,EACLA,EAAW,CACTA,EAAUA,EAAW,CAAC,aAAcA,EAAU8B,EAAYxD,QAC1D0B,EACEA,EAAA,sBAC2C,IAArC8B,EAAYoB,cAAcvD,OAC1B,CAACK,EAAUY,GAAsBkB,EAAYoB,gBAC7C,IAHN,CAIEkC,GAA6BtD,EAAYmB,WACzCjD,GH4HiBhB,EG3HE8C,EAAYtC,UH2HLmG,EG3HgB,KH4H/C3F,EACLA,EAAA,sBACMhB,EAAM,CAAC,IAAKgB,EAAUC,IAAM,EAAOjB,GAAMgB,GAAY,IAD3D,CAEE2F,OG9HQ3F,EACAoF,IAAiB,EAAOtD,EAAYR,MACpC,WAKV,IAAK,iBACH,ODwBC,SAAehD,EAAcoH,GAClC,OAAQA,EAAchK,MACpB,IAAK,OACH,IAAMkK,EAASX,GACb3G,EACA0B,EAAA,CACEA,EAAUA,EAAW,CAAC,YAAaA,EAAU,IAAKA,EAAU,SAD9D,mBAEK0F,EAAc3F,MAAM3C,IAAI,SAAAkB,GAAI,OAC7B0B,EAAUA,EAAW,CAACA,EAAc,IAAKA,EAAU1B,QAHvD,CAKE,QAIJ,OAAO0B,EAAW,CAAC4F,EAAQ5F,EAAcqF,GAAwB/G,KAEnE,IAAK,SACH,OAAO0B,EAAW,CAChBiF,GAAY3G,EAAM4G,GAAY,EAAKQ,EAAczE,QAAQ,IACzDjB,EACAqF,GAAwB/G,KAE5B,IAAK,MACH,IAAMsH,EAASX,GACb3G,EACA0B,EAAW,CACTA,EAASA,EAAW,CAACA,EAAcA,IAAnC,sBACKV,EAAeoG,EAAcX,aAAc,SAAAc,GAAW,OACzB,IAA9BA,EAAY5E,OAAOtB,OACfsF,GACEY,EAAYvH,KACZ4G,GAAY,EAAKW,EAAY5E,QAAQ,IAEvC,QAPR,CASEjB,EACEA,EAAA,CACEA,EACEA,EAAW,CAAC,YAAaA,EAAU,IAAKA,EAAU,SAFtD,mBAIK0F,EAAcX,aAAa3H,IAAI,gBAAEkB,EAAF,EAAEA,KAAM2C,EAAR,EAAQA,OAAR,OAChCjB,EACEA,EAAA,CACEA,EACA,IACAA,EACA1B,EACA0B,EACA,IACAA,EACA,IACAA,EACA,IACAA,GAXF,mBAYwB,IAAlBiB,EAAOtB,OAAe,CAACrB,EAAM,MAAQ,CAAC,SAZ5C,CAaE0B,EACA,WApBR,CAwBE,cAOV,OAAOA,EAAW,CAAC4F,EAAQ5F,EAAcqF,GAAwB/G,KAEnE,IAAK,UACH,OAAO0B,EACLA,EAAW,CACTA,EACEA,EAAW,CACT,aACAA,EACA1B,EACA0B,EACA,IACAA,EACA,OACAA,EACA,QAGJA,EACEA,EAAW,CAACA,EAAUY,IAAU,EAAO8E,EAAc1G,KAAM,UAKnE,QACE,OAAO0G,GCpHAF,CAAoB1D,EAAYxD,KAAMwD,EAAY4D,eAE3D,QACE,OAAO5D,EH+GN,IAAwB9C,EAAS2G,E,gBI1YvBvH,IAAV,SAAUA,GAAQ0H,GAAlB,sEACyB,uBAAOlH,EACnCkH,EAAQxE,KAAKlE,IAAI,SAAAiE,GAAS,OAAI0E,GAA0B1E,MAD5B,QADzB,cACC2E,EADD,uBAKEA,EAAsBrK,OAC3B,SAACE,EAAgBuF,GAAjB,4BACKvF,GADL,YAEKuF,KAEL,KAVG,uCCNO,k+CCKO6E,G,iLACT,IACDC,EAAUC,KAAKC,MAAfF,OAEP,OACE,8BACE,6BAAMA,Q,GANyBG,iB,MCYvC,SAASC,KACP,GAAsB,qBAAXC,OAAwB,CACjC,IAAMC,EAAOD,OAAOE,eAAeC,QAAQ,WAE3C,MAAuB,kBAATF,EAAoBA,EAAOG,GAG3C,OAAOA,GAGT,SAASC,KACP,OAAO,yBAAKC,MAAM,OAAOC,OAAO,OAAOC,cAAY,OAAOC,QAAQ,aAAY,0BAAMC,KAAK,eAAeC,EAAE,oH,IAGvFC,G,2MACnBC,MAAe,CACbC,QAASf,M,EAGXgB,gBAAkB,SAACC,GAAgD,IAC1D/L,EAAS+L,EAAMC,cAAfhM,MAEP,EAAKiM,SAAS,CAACJ,QAAS7L,IAEF,qBAAX+K,QACTA,OAAOE,eAAeiB,QAAQ,UAAWlM,I,wEAIpC6L,GACP,IAME,OALYM,gBAAMN,EAAS,CACzBO,QAAS,CAAC,OAAQ,OAClBC,WAAY,WAId,MAAOC,GAAQ,IACRxK,EAAOwK,EAAPxK,IAEP,MAAM,GAAN,OAAUwK,EAAMtL,QAAhB,eAA8BuL,IAAUV,EAAS/J,EAAIQ,KAAMR,EAAI0K,Y,gCAIzDzC,EAAgB0C,GACxB,IACE,IAAM9L,EZiDHQ,EYjDsBuL,GAAgBD,EAAMnC,UAE/C,OAAQ3J,EAAOT,MACb,IAAK,QACH,OC5DH,SAAe6J,EAAgBrI,GACpC,OAAOA,EACJE,IAAI,SAAA0K,GACH,IAAMK,EAAkBC,2BAAiB7C,EAAQuC,EAAMzK,UAEvD,MAAM,GAAN,OAAU8K,EAAV,eAAgCL,EAAMtL,WAEvCqB,KAAK,kCDqDOwK,CAAY9C,EAAQpJ,EAAOe,QACpC,IAAK,UACH,OAAOf,EAAOX,MAChB,QACE,OAAOW,GAEX,MAAO2L,GACP,OAAOA,EAAMtL,W,mCAIJ8L,GACX,OAAO/K,IAAIgL,QAAQC,kBH3DD1C,EG2DgCwC,EH3DpBG,GG2D4B,EH1DrDzI,EACLA,EAAW,CACTA,EAASA,EAAW,CAACA,EAAcA,IAAnC,sBACMyI,EACA,CAAC,+MAUD,IAZN,YAaK3C,EAAQ1I,IAAI,SAAAsL,GAAc,OAC3B3C,GAAwB2C,QAG5B1I,MGuC+D,CAC/D2I,WAAY,GACZC,SAAU,IACTC,UH9DA,IAAe/C,EAAY2C,I,iCGiErBpB,GACT,IAAMY,EAAQ9B,KAAK2C,SAASzB,GAE5B,GAAqB,kBAAVY,EACT,MAAO,CAACc,IAAKd,EAAOK,OAAQ,GAAIL,MAAO,IAGzC,IAAMK,EAASnC,KAAK6C,UAAU3B,EAASY,GAEvC,MAAsB,kBAAXK,EACF,CAACS,IAAKT,EAAQA,OAAQ,GAAIL,MAAO,IAGnC,CACLc,IAAK5C,KAAK8C,aAAaX,GACvBA,OAAQ7L,KAAKC,UAAU4L,EAAQ,KAAM,GACrCL,MAAOxL,KAAKC,UAAUuL,EAAO,KAAM,M,+BAI7B,IACDZ,EAAWlB,KAAKiB,MAAhBC,QADA,EAEsBlB,KAAK+C,WAAW7B,GAAtC0B,EAFA,EAEAA,IAAKT,EAFL,EAEKA,OAAQL,EAFb,EAEaA,MAEpB,OACE,6BACE,yBAAKkB,UAAU,UACb,4BACE,0BAAMA,UAAU,QACd,0BAAMC,aAAW,QAAQC,KAAK,OAA9B,gBAEQ,IACR,0BAAMD,aAAW,UAAUC,KAAK,OAAhC,iBALJ,YAUE,0BAAMF,UAAU,aAAhB,MAA+B,uBAAGG,KAAK,uBAAuBC,IAAI,sBAAsBC,OAAO,UAAhE,qCAAuG,kBAAC5C,GAAD,QACtI,uBACEuC,UAAU,YACVG,KAAK,2CACLC,IAAI,sBACJC,OAAO,UAJT,aAMc,kBAAC5C,GAAD,SAIlB,yBAAKuC,UAAU,mBACb,8DACA,8BAAUM,SAAUtD,KAAKmB,gBAAiB9L,MAAO6L,KAEnD,yBAAK8B,UAAU,oBACb,0DACA,kBAAC,GAAD,CAAQjD,OAAQ6C,KAElB,yBAAKI,UAAU,gBACb,2DACA,kBAAC,GAAD,CAAQjD,OAAQ+B,KAElB,yBAAKkB,UAAU,iBACb,oDACA,kBAAC,GAAD,CAAQjD,OAAQoC,U,GApHOjC,iBErBbqD,QACW,cAA7BnD,OAAOlJ,SAASsM,UAEe,UAA7BpD,OAAOlJ,SAASsM,UAEhBpD,OAAOlJ,SAASsM,SAASC,MACvB,2DCXN,IAAMC,GAAcC,SAASC,eAAe,QAExCF,IACFG,IAASC,OAAO,kBAAC,GAAD,MAASJ,IDuHrB,kBAAmBK,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC,iB","file":"static/js/main.978f0d86.chunk.js","sourcesContent":["// @flow\n// This monad is used internally by the compiler. It handles the user errors.\n// In contrast to exceptions, it supports one or many errors. Thus the user\n// may get all the errors found by the compiler at once.\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Result from \"./result.js\";\n\ntype Yield =\n  | {\n      type: \"All\",\n      expressions: Generator<Yield, any, any>[],\n    }\n  | {\n      type: \"Raise\",\n      message: string,\n      node: BabelAst.Node,\n    };\n\nexport type t<A> = Generator<Yield, A, any>;\n\n// eslint-disable-next-line require-yield\nexport function* ret<A>(value: A): t<A> {\n  return value;\n}\n\n// Evaluate an array of expressions.\n// Keep all the errors in case there are many.\nexport function* all<A>(expressions: t<A>[]): t<A[]> {\n  return yield {type: \"All\", expressions};\n}\n\nexport function reduce<Accumulator, A>(\n  array: A[],\n  accumulator: Accumulator,\n  reducer: (accumulator: Accumulator, element: A) => t<Accumulator>,\n): t<Accumulator> {\n  return array.reduce(function*(accumulator, element) {\n    return yield* reducer(yield* accumulator, element);\n  }, ret(accumulator));\n}\n\nexport function filterMap<A, B>(array: A[], f: (element: A) => t<?B>): t<B[]> {\n  return reduce(array, [], function*(accumulator: B[], element) {\n    const result = yield* f(element);\n\n    return result ? [...accumulator, result] : accumulator;\n  });\n}\n\nexport function some<A>(\n  array: A[],\n  predicate: (element: A) => t<boolean>,\n): t<boolean> {\n  return reduce(array, false, function*(areSome, element) {\n    return areSome || (yield* predicate(element));\n  });\n}\n\nexport function* raise<A>(node: BabelAst.Node, message: string): t<A> {\n  return yield {type: \"Raise\", message, node};\n}\n\nexport function* raiseUnhandled<A>(node: BabelAst.Node): t<A> {\n  return yield* raise<A>(\n    node,\n    `Unhandled syntax:\\n${JSON.stringify(node, null, 2)}`,\n  );\n}\n\nfunction runWithAnswer<A>(expression: t<A>, answer?: any): Result.t<any> {\n  const result = expression.next(answer);\n\n  if (result.done) {\n    return {\n      type: \"Success\",\n      value: result.value,\n    };\n  }\n\n  const nextAnswer: Result.t<any> = (() => {\n    switch (result.value.type) {\n      case \"All\": {\n        const results = result.value.expressions.map(expression =>\n          runWithAnswer(expression),\n        );\n\n        return Result.merge(results);\n      }\n      case \"Raise\": {\n        const error = {\n          location: result.value.node.loc,\n          message: result.value.message,\n        };\n\n        return {type: \"Error\", errors: [error]};\n      }\n      /* istanbul ignore next */\n      default:\n        return result.value;\n    }\n  })();\n\n  switch (nextAnswer.type) {\n    case \"Error\":\n      return nextAnswer;\n    case \"Success\":\n      return runWithAnswer(expression, nextAnswer.value);\n    /* istanbul ignore next */\n    default:\n      return nextAnswer;\n  }\n}\n\nexport function run<A>(expression: t<A>): Result.t<A> {\n  return runWithAnswer(expression);\n}\n","// @flow\nimport * as Error from \"./error.js\";\n\nexport type t<A> =\n  | {\n      type: \"Error\",\n      errors: Error.t[],\n    }\n  | {\n      type: \"Success\",\n      value: A,\n    };\n\nexport function merge<A>(results: t<A>[]): t<A[]> {\n  return results.reduce(\n    (accumulator: t<A[]>, result: t<A>) => {\n      switch (accumulator.type) {\n        case \"Error\":\n          switch (result.type) {\n            case \"Error\":\n              return {\n                type: \"Error\",\n                errors: [...accumulator.errors, ...result.errors],\n              };\n            case \"Success\":\n              return {\n                type: \"Error\",\n                errors: accumulator.errors,\n              };\n            /* istanbul ignore next */\n            default:\n              return result;\n          }\n        case \"Success\":\n          switch (result.type) {\n            case \"Error\":\n              return {\n                type: \"Error\",\n                errors: result.errors,\n              };\n            case \"Success\":\n              return {\n                type: \"Success\",\n                value: [...accumulator.value, result.value],\n              };\n            /* istanbul ignore next */\n            default:\n              return result;\n          }\n        /* istanbul ignore next */\n        default:\n          return accumulator;\n      }\n    },\n    {type: \"Success\", value: []},\n  );\n}\n","// @flow\n// A wrapper around Prettier doc primitives.\nimport doc from \"prettier/doc.js\";\n\ndeclare opaque type Doc;\n\nexport type t = Doc | string;\n\nconst {\n  concat,\n  group,\n  hardline,\n  indent,\n  join,\n  line,\n  softline,\n}: {\n  concat: (docs: $ReadOnlyArray<t>) => t,\n  group: (doc: t) => t,\n  hardline: t,\n  indent: (doc: t) => t,\n  join: (sep: t, docs: $ReadOnlyArray<t>) => t,\n  line: t,\n  softline: t,\n} = doc.builders;\n\nexport {concat, group, hardline, indent, join, line, softline};\n\nexport function paren(needParens: boolean, doc: t): t {\n  return needParens ? group(concat([\"(\", doc, \")\"])) : doc;\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\n\nconst nameMapping: {[name: string]: string} = {\n  Props: \"_Props\",\n};\n\nexport function compile(identifier: BabelAst.Identifier): string {\n  const {name} = identifier;\n\n  return nameMapping[name] || name;\n}\n","// @flow\n\nexport function filterMap<A, B>(array: A[], f: (element: A) => ?B): B[] {\n  return array.reduce((accumulator: B[], element) => {\n    const result = f(element);\n\n    return result ? [...accumulator, result] : accumulator;\n  }, []);\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Util from \"./util.js\";\n\nexport type t =\n  | {\n      type: \"Function\",\n      params: t[],\n      returnTyp: t,\n      typParams: string[],\n    }\n  | {\n      type: \"Implicit\",\n    }\n  | {\n      type: \"Tuple\",\n      params: t[],\n    }\n  | {\n      type: \"Variable\",\n      name: string,\n      params: t[],\n    };\n\nexport function* getObjectKeyName(key: any): Monad.t<string> {\n  switch (key.type) {\n    case \"Identifier\":\n      return Identifier.compile(key);\n    case \"StringLiteral\":\n      return key.value;\n    default:\n      return yield* Monad.raise<string>(key, \"Computed key name not handled\");\n  }\n}\n\nfunction compileIdentifierOrQualifiedTypeIdentifier(\n  id: BabelAst.Identifier | BabelAst.QualifiedTypeIdentifier,\n): string {\n  switch (id.type) {\n    case \"Identifier\":\n      return Identifier.compile(id);\n    case \"QualifiedTypeIdentifier\":\n      return `${compileIdentifierOrQualifiedTypeIdentifier(\n        id.qualification,\n      )}.${Identifier.compile(id.id)}`;\n    /* istanbul ignore next */\n    default:\n      return id;\n  }\n}\n\nexport function* compileIdentifier(typ: BabelAst.FlowType): Monad.t<string> {\n  switch (typ.type) {\n    case \"GenericTypeAnnotation\":\n      return compileIdentifierOrQualifiedTypeIdentifier(typ.id);\n    default:\n      return yield* Monad.raise<string>(typ, \"Expected a type identifier\");\n  }\n}\n\ntype PlainTypOrRest =\n  | {\n      type: \"PlainTyp\",\n      typ: t,\n    }\n  | {\n      type: \"Rest\",\n      typ:\n        | BabelAst.ObjectTypeAnnotation\n        | BabelAst.StringLiteralTypeAnnotation\n        | BabelAst.UnionTypeAnnotation,\n    };\n\nexport function* compileIfPlainTyp(\n  typ: BabelAst.FlowType,\n): Monad.t<PlainTypOrRest> {\n  switch (typ.type) {\n    case \"AnyTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"The type `any` is not handled\",\n      );\n    case \"ArrayTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"list\",\n          params: [yield* compile(typ.elementType)],\n        },\n      };\n    case \"BooleanLiteralTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"Boolean literals in types are not handled\",\n      );\n    case \"BooleanTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"bool\",\n          params: [],\n        },\n      };\n    case \"EmptyTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"Empty_set\",\n          params: [],\n        },\n      };\n    case \"ExistsTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Implicit\",\n        },\n      };\n    case \"FunctionTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Function\",\n          params: yield* Monad.all(\n            typ.params.map(({typeAnnotation}) => compile(typeAnnotation)),\n          ),\n          returnTyp: yield* compile(typ.returnType),\n          typParams: typ.typeParameters\n            ? Util.filterMap(typ.typeParameters.params, param => param.name)\n            : [],\n        },\n      };\n    case \"GenericTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: compileIdentifierOrQualifiedTypeIdentifier(typ.id),\n          params: [],\n        },\n      };\n    case \"InterfaceTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"Interface types are not handled\",\n      );\n    case \"IntersectionTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"Intersection types are not handled\",\n      );\n    case \"MixedTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"The type `mixed` is not handled\",\n      );\n    case \"NullableTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"option\",\n          params: [yield* compile(typ.typeAnnotation)],\n        },\n      };\n    case \"NullLiteralTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"unit\",\n          params: [],\n        },\n      };\n    case \"NumberLiteralTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"Number literals in types are not handled\",\n      );\n    case \"NumberTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"Z\",\n          params: [],\n        },\n      };\n    case \"ObjectTypeAnnotation\": {\n      if (typ.properties.length === 0) {\n        return {\n          type: \"PlainTyp\",\n          typ: {\n            type: \"Variable\",\n            name: \"unit\",\n            params: [],\n          },\n        };\n      }\n\n      return {\n        type: \"Rest\",\n        typ,\n      };\n    }\n    case \"StringLiteralTypeAnnotation\":\n      return {\n        type: \"Rest\",\n        typ,\n      };\n    case \"StringTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"string\",\n          params: [],\n        },\n      };\n    case \"ThisTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"The type `this` is not handled\",\n      );\n    case \"TupleTypeAnnotation\":\n      if (typ.types.length === 1) {\n        return yield* Monad.raise<PlainTypOrRest>(\n          typ,\n          \"Tuple types with exactly one element are not handled\",\n        );\n      }\n\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Tuple\",\n          params: yield* Monad.all(typ.types.map(typ => compile(typ))),\n        },\n      };\n    case \"TypeofTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"Extracting the type of values with `typeof` is not handled\",\n      );\n    case \"UnionTypeAnnotation\":\n      return {\n        type: \"Rest\",\n        typ,\n      };\n    case \"VoidTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"unit\",\n          params: [],\n        },\n      };\n    /* istanbul ignore next */\n    default:\n      return typ;\n  }\n}\n\nexport function* compile(typ: BabelAst.FlowType): Monad.t<t> {\n  const compiledTyp = yield* compileIfPlainTyp(typ);\n\n  switch (compiledTyp.type) {\n    case \"PlainTyp\":\n      return compiledTyp.typ;\n    case \"Rest\":\n      switch (compiledTyp.typ.type) {\n        case \"ObjectTypeAnnotation\":\n          return yield* Monad.raise<t>(\n            compiledTyp.typ,\n            \"This kind of object type is not handled outside of type definitions\",\n          );\n        case \"StringLiteralTypeAnnotation\":\n          return yield* Monad.raise<t>(\n            compiledTyp.typ,\n            \"String literal types are not handled outside of type definitions\",\n          );\n        case \"UnionTypeAnnotation\":\n          return yield* Monad.raise<t>(\n            compiledTyp.typ,\n            \"Union types are not handled outside of type definitions\",\n          );\n        /* istanbul ignore next */\n        default:\n          return compiledTyp.typ;\n      }\n    /* istanbul ignore next */\n    default:\n      return compiledTyp;\n  }\n}\n\nexport function printImplicitTyps(names: string[]): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"{\",\n      Doc.indent(\n        Doc.concat([\n          Doc.softline,\n          Doc.join(Doc.line, names),\n          Doc.line,\n          Doc.group(Doc.concat([\":\", Doc.line, \"Type\"])),\n        ]),\n      ),\n      Doc.softline,\n      \"}\",\n    ]),\n  );\n}\n\nexport function print(needParens: boolean, typ: t): Doc.t {\n  switch (typ.type) {\n    case \"Function\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            ...(typ.typParams.length !== 0\n              ? [\n                  Doc.group(\n                    Doc.concat([\n                      \"forall\",\n                      Doc.line,\n                      \"{\",\n                      Doc.indent(\n                        Doc.group(\n                          Doc.concat([\n                            Doc.softline,\n                            ...typ.typParams.map(typParam =>\n                              Doc.concat([typParam, Doc.line]),\n                            ),\n                            Doc.group(Doc.concat([\":\", Doc.line, \"Type\"])),\n                          ]),\n                        ),\n                      ),\n                      Doc.softline,\n                      \"}\",\n                      \",\",\n                      Doc.line,\n                    ]),\n                  ),\n                ]\n              : []),\n            ...typ.params.map(param =>\n              Doc.group(\n                Doc.concat([print(true, param), Doc.line, \"->\", Doc.line]),\n              ),\n            ),\n            print(true, typ.returnTyp),\n          ]),\n        ),\n      );\n    case \"Implicit\":\n      return \"_\";\n    case \"Tuple\":\n      switch (typ.params.length) {\n        case 0:\n          return \"unit\";\n        default:\n          return Doc.paren(\n            needParens,\n            Doc.group(\n              Doc.join(\n                Doc.concat([Doc.line, \"*\", Doc.line]),\n                typ.params.map(param => print(true, param)),\n              ),\n            ),\n          );\n      }\n    case \"Variable\":\n      return Doc.paren(\n        needParens && typ.params.length !== 0,\n        Doc.group(\n          Doc.concat([\n            typ.name,\n            Doc.indent(\n              Doc.concat(\n                typ.params.map(param =>\n                  Doc.concat([Doc.line, print(true, param)]),\n                ),\n              ),\n            ),\n          ]),\n        ),\n      );\n    /* istanbul ignore next */\n    default:\n      return typ;\n  }\n}\n\nexport function printReturnTyp(typ: ?t, nextToken: Doc.t): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      ...(typ ? [\":\", Doc.line, print(false, typ), Doc.line] : []),\n      nextToken,\n    ]),\n  );\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as Util from \"./util.js\";\n\ntype LeftValueRecordField = {\n  name: string,\n  variable: string,\n};\n\ntype LeftValue =\n  | {\n      type: \"Record\",\n      fields: LeftValueRecordField[],\n      record: string,\n    }\n  | {\n      type: \"Variable\",\n      name: string,\n    };\n\nexport type t =\n  | {\n      type: \"ArrayExpression\",\n      elements: t[],\n    }\n  | {\n      type: \"BinaryExpression\",\n      left: t,\n      operator: string,\n      right: t,\n    }\n  | {\n      type: \"CallExpression\",\n      arguments: t[],\n      callee: t,\n    }\n  | {\n      type: \"ConditionalExpression\",\n      alternate: t,\n      consequent: t,\n      test: t,\n    }\n  | {\n      type: \"Constant\",\n      value: boolean | number | string,\n    }\n  | {\n      type: \"EnumDestruct\",\n      branches: {body: t, names: string[]}[],\n      defaultBranch: ?t,\n      discriminant: t,\n      typName: string,\n    }\n  | {\n      type: \"EnumInstance\",\n      instance: string,\n      typName: string,\n    }\n  | {\n      type: \"FunctionExpression\",\n      // eslint-disable-next-line no-use-before-define\n      value: Fun,\n    }\n  | {\n      type: \"Let\",\n      body: t,\n      lval: LeftValue,\n      value: t,\n    }\n  | {\n      type: \"RecordInstance\",\n      // eslint-disable-next-line no-use-before-define\n      fields: RecordField[],\n      record: string,\n    }\n  | {\n      type: \"RecordProjection\",\n      field: string,\n      object: t,\n      record: string,\n    }\n  | {\n      type: \"RecordUpdate\",\n      field: string,\n      object: t,\n      record: string,\n      update: t,\n    }\n  | {\n      type: \"SumDestruct\",\n      branches: {body: t, fields: LeftValueRecordField[], name: string}[],\n      defaultBranch: ?t,\n      discriminant: t,\n      sum: string,\n    }\n  | {\n      type: \"SumInstance\",\n      constr: string,\n      // eslint-disable-next-line no-use-before-define\n      fields: RecordField[],\n      sum: string,\n    }\n  | {\n      type: \"TypeCastExpression\",\n      expression: t,\n      typeAnnotation: Typ.t,\n    }\n  | {\n      type: \"UnaryExpression\",\n      argument: t,\n      operator: string,\n    }\n  | {\n      type: \"Variable\",\n      name: string,\n    };\n\nexport type FunArgument = {\n  name: string,\n  typ: ?Typ.t,\n};\n\nexport type Fun = {\n  arguments: FunArgument[],\n  body: t,\n  returnTyp: ?Typ.t,\n  typParameters: string[],\n};\n\ntype RecordField = {\n  name: string,\n  value: t,\n};\n\nexport const tt: t = {\n  type: \"Variable\",\n  name: \"tt\",\n};\n\nfunction* getObjectPropertyName(\n  property: BabelAst.ObjectProperty,\n): Monad.t<string> {\n  return yield* Typ.getObjectKeyName(property.key);\n}\n\nfunction* getLeftValueRecordFields(\n  pattern: BabelAst.ObjectPattern,\n): Monad.t<LeftValueRecordField[]> {\n  return yield* Monad.all(\n    pattern.properties.map(function*(property) {\n      switch (property.type) {\n        case \"ObjectProperty\":\n          switch (property.value.type) {\n            case \"Identifier\": {\n              const {value} = property;\n\n              return {\n                name: yield* getObjectPropertyName(property),\n                variable: Identifier.compile(value),\n              };\n            }\n            default:\n              return yield* Monad.raise<LeftValueRecordField>(\n                property.value,\n                \"Expected an identifier\",\n              );\n          }\n        case \"RestElement\":\n          return yield* Monad.raise<LeftValueRecordField>(\n            property,\n            \"Unhandled rest element for record destructuring\",\n          );\n        /* istanbul ignore next */\n        default:\n          return property;\n      }\n    }),\n  );\n}\n\nfunction* compileLVal(lval: BabelAst.LVal): Monad.t<LeftValue> {\n  switch (lval.type) {\n    case \"ArrayPattern\":\n      return yield* Monad.raise<LeftValue>(lval, \"Unhandled array patterns\");\n    /* istanbul ignore next */\n    case \"AssignmentPattern\":\n      return yield* Monad.raise<LeftValue>(\n        lval,\n        \"Unexpected assignment patterns\",\n      );\n    case \"Identifier\":\n      return {\n        type: \"Variable\",\n        name: Identifier.compile(lval),\n      };\n    /* istanbul ignore next */\n    case \"MemberExpression\":\n      return yield* Monad.raise<LeftValue>(lval, \"Unexpected member access\");\n    case \"ObjectPattern\": {\n      const typName = lval.typeAnnotation\n        ? yield* Typ.compileIdentifier(lval.typeAnnotation.typeAnnotation)\n        : yield* Monad.raise<string>(\n            lval,\n            \"Expected a type annotation for record destructuring\",\n          );\n      const fields = yield* getLeftValueRecordFields(lval);\n\n      return {\n        type: \"Record\",\n        fields,\n        record: typName,\n      };\n    }\n    /* istanbul ignore next */\n    case \"RestElement\":\n      return yield* Monad.raise<LeftValue>(lval, \"Unexpected rest elements\");\n    /* istanbul ignore next */\n    default:\n      return lval;\n  }\n}\n\nfunction* getStringOfStringLiteral(\n  expression: BabelAst.Expression,\n): Monad.t<string> {\n  switch (expression.type) {\n    case \"StringLiteral\":\n      return expression.value;\n    default:\n      return yield* Monad.raise<string>(\n        expression,\n        \"Expected a string literal\",\n      );\n  }\n}\n\nfunction isEmptyDefaultBranch(statements: BabelAst.Statement[]): boolean {\n  if (statements.length >= 1) {\n    const statement = statements[0];\n    switch (statement.type) {\n      case \"BlockStatement\":\n        return isEmptyDefaultBranch(statement.body);\n      case \"ReturnStatement\":\n        if (statement.argument) {\n          switch (statement.argument.type) {\n            case \"TypeCastExpression\":\n              switch (statement.argument.typeAnnotation.typeAnnotation.type) {\n                case \"EmptyTypeAnnotation\":\n                  return true;\n                default:\n                  return false;\n              }\n            default:\n              return false;\n          }\n        }\n        return false;\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}\n\ntype FieldsDestructuringFromHeadStatement = {\n  fields: LeftValueRecordField[],\n  trailingStatements: BabelAst.Statement[],\n};\n\nfunction* getFieldsDestructuringFromHeadStatement(\n  statements: BabelAst.Statement[],\n  discriminantName: string,\n): Monad.t<FieldsDestructuringFromHeadStatement> {\n  const noDestructuring = {fields: [], trailingStatements: statements};\n\n  if (statements.length === 0) {\n    return noDestructuring;\n  }\n\n  const headStatement = statements[0];\n\n  switch (headStatement.type) {\n    case \"BlockStatement\":\n      return yield* getFieldsDestructuringFromHeadStatement(\n        [...headStatement.body, ...statements.slice(1)],\n        discriminantName,\n      );\n    case \"VariableDeclaration\": {\n      if (headStatement.declarations.length !== 1) {\n        return yield* Monad.raise<FieldsDestructuringFromHeadStatement>(\n          headStatement,\n          \"Expected a single definition of variable\",\n        );\n      }\n\n      const declaration = headStatement.declarations[0];\n\n      if (declaration.init) {\n        switch (declaration.init.type) {\n          case \"Identifier\": {\n            const {name} = declaration.init;\n\n            if (name === discriminantName) {\n              switch (declaration.id.type) {\n                case \"ObjectPattern\": {\n                  const fields = yield* getLeftValueRecordFields(\n                    declaration.id,\n                  );\n\n                  return {\n                    fields,\n                    trailingStatements: statements.slice(1),\n                  };\n                }\n                default:\n                  return yield* Monad.raise<FieldsDestructuringFromHeadStatement>(\n                    declaration.id,\n                    \"Expected an object pattern to destructure a sum type\",\n                  );\n              }\n            }\n\n            return noDestructuring;\n          }\n          default:\n            return noDestructuring;\n        }\n      }\n\n      return noDestructuring;\n    }\n    default:\n      return noDestructuring;\n  }\n}\n\nexport function* compileStatements(\n  statements: BabelAst.Statement[],\n): Monad.t<t> {\n  if (statements.length === 0) {\n    return tt;\n  }\n\n  const statement = statements[0];\n\n  switch (statement.type) {\n    case \"BlockStatement\":\n      return yield* compileStatements([\n        ...statement.body,\n        ...statements.slice(1),\n      ]);\n    case \"ReturnStatement\":\n      return statement.argument ? yield* compile(statement.argument) : tt;\n    case \"SwitchStatement\": {\n      const {discriminant, cases} = statement;\n      const firstTrailingComment =\n        discriminant.trailingComments &&\n        discriminant.trailingComments.length !== 0\n          ? discriminant.trailingComments[0].value.trim()\n          : yield* Monad.raise<string>(\n              discriminant,\n              \"Expected a trailing comment with the type name on which we discriminate\",\n            );\n\n      switch (discriminant.type) {\n        // Destructuring of sum type.\n        case \"MemberExpression\": {\n          const field = yield* Typ.getObjectKeyName(discriminant.property);\n\n          if (field !== \"type\") {\n            return yield* Monad.raise<t>(\n              discriminant.property,\n              \"Expected an access on the `type` field to destructure a sum type\",\n            );\n          }\n\n          const expression = discriminant.object;\n\n          switch (expression.type) {\n            case \"Identifier\": {\n              const discriminantName = expression.name;\n              const branches = yield* Monad.filterMap(cases, function*({\n                consequent,\n                test,\n              }) {\n                if (!test) {\n                  return null;\n                }\n\n                const {\n                  fields,\n                  trailingStatements,\n                } = yield* getFieldsDestructuringFromHeadStatement(\n                  consequent,\n                  discriminantName,\n                );\n\n                return {\n                  body: yield* compileStatements(trailingStatements),\n                  fields,\n                  name: yield* getStringOfStringLiteral(test),\n                };\n              });\n              const defaultCase =\n                cases.find(\n                  branch =>\n                    !branch.test && !isEmptyDefaultBranch(branch.consequent),\n                ) || null;\n\n              return {\n                type: \"SumDestruct\",\n                branches,\n                defaultBranch:\n                  defaultCase &&\n                  (yield* compileStatements(defaultCase.consequent)),\n                discriminant: yield* compile(expression),\n                sum: firstTrailingComment,\n              };\n            }\n            default:\n              return yield* Monad.raise<t>(\n                expression,\n                \"Expected a switch on an identifier to destructure a sum type\",\n              );\n          }\n        }\n        // Destructuring of enum.\n        default: {\n          const {accumulatedNames, branches} = yield* Monad.reduce<\n            {\n              accumulatedNames: string[],\n              branches: {body: t, names: string[]}[],\n            },\n            BabelAst.SwitchCase,\n          >(cases, {accumulatedNames: [], branches: []}, function*(\n            {accumulatedNames, branches},\n            branch,\n          ) {\n            if (!branch.test) {\n              return {accumulatedNames: [], branches};\n            }\n\n            const name = yield* getStringOfStringLiteral(branch.test);\n            const currentAccumulatedNames = [...accumulatedNames, name];\n\n            if (branch.consequent.length === 0) {\n              return {accumulatedNames: currentAccumulatedNames, branches};\n            }\n\n            return {\n              accumulatedNames: [],\n              branches: [\n                ...branches,\n                {\n                  body: yield* compileStatements(branch.consequent),\n                  names: currentAccumulatedNames,\n                },\n              ],\n            };\n          });\n          const defaultCase =\n            cases.find(\n              branch =>\n                !branch.test && !isEmptyDefaultBranch(branch.consequent),\n            ) || null;\n\n          return {\n            type: \"EnumDestruct\",\n            branches: [\n              ...branches,\n              ...(accumulatedNames.length !== 0\n                ? [{body: tt, names: accumulatedNames}]\n                : []),\n            ],\n            defaultBranch:\n              defaultCase && (yield* compileStatements(defaultCase.consequent)),\n            discriminant: yield* compile(discriminant),\n            typName: firstTrailingComment,\n          };\n        }\n      }\n    }\n    case \"VariableDeclaration\": {\n      if (statement.declarations.length !== 1) {\n        return yield* Monad.raise<t>(\n          statement,\n          \"Expected exactly one definition\",\n        );\n      }\n\n      const declaration = statement.declarations[0];\n\n      return {\n        type: \"Let\",\n        body: yield* compileStatements(statements.slice(1)),\n        lval: yield* compileLVal(declaration.id),\n        value: declaration.init\n          ? yield* compile(declaration.init)\n          : yield* Monad.raise<t>(\n              declaration,\n              \"Expected a definition with a value\",\n            ),\n      };\n    }\n    default:\n      return yield* Monad.raiseUnhandled<t>(statement);\n  }\n}\n\nexport function* compileFun(\n  fun:\n    | BabelAst.FunctionDeclaration\n    | BabelAst.FunctionExpression\n    | BabelAst.ArrowFunctionExpression,\n): Monad.t<Fun> {\n  const returnTyp = fun.returnType ? fun.returnType.typeAnnotation : null;\n\n  return {\n    arguments: yield* Monad.all(\n      fun.params.map(function*(param) {\n        switch (param.type) {\n          case \"Identifier\":\n            return {\n              name: param.name,\n              typ: param.typeAnnotation\n                ? yield* Typ.compile(param.typeAnnotation.typeAnnotation)\n                : null,\n            };\n          default:\n            return yield* Monad.raise<FunArgument>(\n              param,\n              \"Expected simple identifier as function parameter\",\n            );\n        }\n      }),\n    ),\n    body:\n      fun.body.type === \"BlockStatement\"\n        ? yield* compileStatements(fun.body.body)\n        : yield* compile(fun.body),\n    returnTyp: returnTyp && (yield* Typ.compile(returnTyp)),\n    typParameters: fun.typeParameters\n      ? Util.filterMap(fun.typeParameters.params, param => param.name)\n      : [],\n  };\n}\n\nexport function* compile(expression: BabelAst.Expression): Monad.t<t> {\n  switch (expression.type) {\n    case \"ArrayExpression\":\n      return {\n        type: \"ArrayExpression\",\n        elements: expression.elements\n          ? yield* Monad.all(\n              expression.elements.map(function*(element) {\n                if (!element) {\n                  return yield* Monad.raise<t>(\n                    expression,\n                    \"Expected non-empty elements in the array\",\n                  );\n                }\n\n                if (element.type === \"SpreadElement\") {\n                  return yield* Monad.raise<t>(\n                    element,\n                    \"Spreads in arrays are not handled\",\n                  );\n                }\n\n                return yield* compile(element);\n              }),\n            )\n          : /* istanbul ignore next */\n            yield* Monad.raise<t[]>(\n              expression,\n              \"Unexpected empty array expression\",\n            ),\n      };\n    case \"ArrowFunctionExpression\":\n      return {\n        type: \"FunctionExpression\",\n        value: yield* compileFun(expression),\n      };\n    case \"BinaryExpression\":\n      return {\n        type: \"BinaryExpression\",\n        left: yield* compile(expression.left),\n        operator: expression.operator,\n        right: yield* compile(expression.right),\n      };\n    case \"BooleanLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"CallExpression\":\n      return {\n        type: \"CallExpression\",\n        arguments: yield* Monad.all(\n          expression.arguments.map(function*(argument) {\n            switch (argument.type) {\n              case \"ArgumentPlaceholder\":\n                return yield* Monad.raise<t>(\n                  argument,\n                  \"Unhandled partial application\",\n                );\n              case \"SpreadElement\":\n                return yield* Monad.raise<t>(\n                  argument,\n                  \"Unhandled spread parameters\",\n                );\n              default:\n                return yield* compile(argument);\n            }\n          }),\n        ),\n        callee: yield* compile(expression.callee),\n      };\n    case \"ConditionalExpression\":\n      return {\n        type: \"ConditionalExpression\",\n        alternate: yield* compile(expression.alternate),\n        consequent: yield* compile(expression.consequent),\n        test: yield* compile(expression.test),\n      };\n    case \"FunctionExpression\":\n      return {\n        type: \"FunctionExpression\",\n        value: yield* compileFun(expression),\n      };\n    case \"Identifier\":\n      return {\n        type: \"Variable\",\n        name: expression.name,\n      };\n    case \"LogicalExpression\":\n      return {\n        type: \"BinaryExpression\",\n        left: yield* compile(expression.left),\n        operator: expression.operator,\n        right: yield* compile(expression.right),\n      };\n    case \"MemberExpression\": {\n      switch (expression.object.type) {\n        case \"TypeCastExpression\": {\n          const {expression: object, typeAnnotation} = expression.object;\n          const record = yield* Typ.compileIdentifier(\n            typeAnnotation.typeAnnotation,\n          );\n          const field = yield* Typ.getObjectKeyName(expression.property);\n\n          return {\n            type: \"RecordProjection\",\n            field,\n            object: yield* compile(object),\n            record,\n          };\n        }\n        default:\n          return yield* Monad.raise<t>(\n            expression.object,\n            \"Expected a type annotation on this object to access a member\",\n          );\n      }\n    }\n    case \"NullLiteral\":\n      return tt;\n    case \"NumericLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"ObjectExpression\": {\n      if (expression.properties.length === 0) {\n        return tt;\n      }\n\n      return yield* Monad.raise<t>(\n        expression,\n        \"Unhandled object expression without type annotation\",\n      );\n    }\n    /* istanbul ignore next */\n    case \"ParenthesizedExpression\":\n      return yield* compile(expression.expression);\n    case \"StringLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"TypeCastExpression\": {\n      switch (expression.expression.type) {\n        case \"ObjectExpression\": {\n          const [names, fields, spreads] = yield* Monad.reduce(\n            expression.expression.properties,\n            ([[], [], []]: [string[], RecordField[], t[]]),\n            function*([names, fields, spreads], property) {\n              switch (property.type) {\n                case \"ObjectMethod\":\n                  return yield* Monad.raise<[*, *, *]>(\n                    property,\n                    \"Object methods not handled\",\n                  );\n                case \"ObjectProperty\": {\n                  if (property.computed) {\n                    return yield* Monad.raise<[*, *, *]>(\n                      property.key,\n                      \"Unhandled computed property name\",\n                    );\n                  }\n\n                  const name = yield* getObjectPropertyName(property);\n                  // Because this seems to be the case here and for\n                  // performance reasons for the type checking.\n                  const value: BabelAst.Expression = (property.value: any);\n\n                  if (name === \"type\") {\n                    return [\n                      [...names, yield* getStringOfStringLiteral(value)],\n                      fields,\n                      spreads,\n                    ];\n                  }\n\n                  return [\n                    names,\n                    [...fields, {name, value: yield* compile(value)}],\n                    spreads,\n                  ];\n                }\n                case \"SpreadElement\":\n                  if (names.length !== 0 || fields.length !== 0) {\n                    yield* Monad.raise<[*, *, *]>(\n                      property,\n                      \"Spread element must be the first element of the object\",\n                    );\n                  }\n\n                  return [\n                    names,\n                    fields,\n                    [...spreads, yield* compile(property.argument)],\n                  ];\n                /* istanbul ignore next */\n                default:\n                  return property;\n              }\n            },\n          );\n          const typName = yield* Typ.compileIdentifier(\n            expression.typeAnnotation.typeAnnotation,\n          );\n\n          if (names.length >= 2) {\n            return yield* Monad.raise<t>(\n              expression.expression,\n              \"Ambiguous multiple `type` fields\",\n            );\n          }\n          if (spreads.length >= 2) {\n            return yield* Monad.raise<t>(\n              expression.expression,\n              `At most one spread element per object is handled, found ${spreads.length}`,\n            );\n          }\n\n          if (names.length === 0) {\n            if (spreads.length === 0) {\n              return {type: \"RecordInstance\", record: typName, fields};\n            }\n\n            return fields.reduce(\n              (accumulator, field) => ({\n                type: \"RecordUpdate\",\n                field: field.name,\n                object: accumulator,\n                record: typName,\n                update: field.value,\n              }),\n              spreads[0],\n            );\n          }\n\n          if (spreads.length === 0) {\n            return {\n              type: \"SumInstance\",\n              constr: names[0],\n              fields,\n              sum: typName,\n            };\n          }\n\n          return yield* Monad.raise<t>(\n            expression.expression,\n            \"Spread elements in sum types are not handled\",\n          );\n        }\n        case \"StringLiteral\": {\n          const {value} = expression.expression;\n\n          return {\n            type: \"EnumInstance\",\n            instance: value,\n            typName: yield* Typ.compileIdentifier(\n              expression.typeAnnotation.typeAnnotation,\n            ),\n          };\n        }\n        default:\n          return {\n            type: \"TypeCastExpression\",\n            expression: yield* compile(expression.expression),\n            typeAnnotation: yield* Typ.compile(\n              expression.typeAnnotation.typeAnnotation,\n            ),\n          };\n      }\n    }\n    case \"UnaryExpression\":\n      return {\n        type: \"UnaryExpression\",\n        argument: yield* compile(expression.argument),\n        operator: expression.operator,\n      };\n    default:\n      return yield* Monad.raiseUnhandled<t>(expression);\n  }\n}\n\nexport function printFunArguments(funArguments: FunArgument[]): Doc.t {\n  return Doc.concat(\n    funArguments.map(({name, typ}) =>\n      Doc.concat([\n        Doc.line,\n        typ\n          ? Doc.group(\n              Doc.concat([\n                \"(\",\n                name,\n                Doc.line,\n                \":\",\n                Doc.line,\n                Typ.print(false, typ),\n                \")\",\n              ]),\n            )\n          : name,\n      ]),\n    ),\n  );\n}\n\nfunction printCallExpression(\n  needParens: boolean,\n  callee: Doc.t,\n  args: Doc.t[],\n): Doc.t {\n  return Doc.paren(\n    needParens,\n    Doc.group(Doc.indent(Doc.join(Doc.line, [callee, ...args]))),\n  );\n}\n\nexport function printRecordInstance(\n  record: ?string,\n  fields: {name: string, value: Doc.t}[],\n): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"{|\",\n      Doc.indent(\n        Doc.concat(\n          fields.map(({name, value}) =>\n            Doc.concat([\n              Doc.line,\n              Doc.group(\n                Doc.concat([\n                  Doc.group(\n                    Doc.concat([\n                      record ? `${record}.${name}` : name,\n                      Doc.line,\n                      \":=\",\n                    ]),\n                  ),\n                  Doc.indent(Doc.concat([Doc.line, value, \";\"])),\n                ]),\n              ),\n            ]),\n          ),\n        ),\n      ),\n      Doc.line,\n      \"|}\",\n    ]),\n  );\n}\n\nfunction printLeftValue(lval: LeftValue, withQuote: boolean): Doc.t {\n  switch (lval.type) {\n    case \"Record\":\n      if (lval.fields.length === 0) {\n        return \"_\";\n      }\n\n      return Doc.concat([\n        ...(withQuote ? [\"'\"] : []),\n        printRecordInstance(\n          lval.record,\n          lval.fields.map(({name, variable}) => ({name, value: variable})),\n        ),\n      ]);\n    case \"Variable\":\n      return lval.name;\n    /* istanbul ignore next */\n    default:\n      return lval;\n  }\n}\n\nfunction printMatch(\n  discriminant: Doc.t,\n  branches: {\n    body: Doc.t,\n    patterns: {\n      fields: ?(LeftValueRecordField[]),\n      name: string,\n    }[],\n  }[],\n  defaultBranch: ?Doc.t,\n  typName: string,\n): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      Doc.group(\n        Doc.concat([\"match\", Doc.line, discriminant, Doc.line, \"with\"]),\n      ),\n      Doc.hardline,\n      ...branches.map(({body, patterns}) =>\n        Doc.group(\n          Doc.concat([\n            Doc.join(\n              Doc.line,\n              patterns.map(({fields, name}) =>\n                Doc.group(\n                  Doc.concat([\n                    \"|\",\n                    Doc.line,\n                    `${typName}.${name}`,\n                    ...(fields\n                      ? [\n                          Doc.line,\n                          printLeftValue(\n                            {\n                              type: \"Record\",\n                              fields,\n                              record: `${typName}.${name}`,\n                            },\n                            false,\n                          ),\n                        ]\n                      : []),\n                  ]),\n                ),\n              ),\n            ),\n            Doc.line,\n            \"=>\",\n            Doc.indent(Doc.concat([Doc.line, body])),\n            Doc.hardline,\n          ]),\n        ),\n      ),\n      ...(defaultBranch\n        ? [\n            Doc.group(\n              Doc.concat([\n                Doc.group(Doc.concat([\"|\", Doc.line, \"_\", Doc.line, \"=>\"])),\n                Doc.indent(Doc.concat([Doc.line, defaultBranch])),\n                Doc.hardline,\n              ]),\n            ),\n          ]\n        : []),\n      \"end\",\n    ]),\n  );\n}\n\nexport function print(needParens: boolean, expression: t): Doc.t {\n  switch (expression.type) {\n    case \"ArrayExpression\":\n      if (expression.elements.length === 0) {\n        return \"[]\";\n      }\n\n      return Doc.group(\n        Doc.concat([\n          \"[\",\n          Doc.indent(\n            Doc.concat([\n              Doc.line,\n              Doc.join(\n                Doc.concat([\";\", Doc.line]),\n                expression.elements.map(element => print(false, element)),\n              ),\n            ]),\n          ),\n          Doc.line,\n          \"]\",\n        ]),\n      );\n    case \"BinaryExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.join(Doc.line, [\n            print(true, expression.left),\n            expression.operator,\n            print(true, expression.right),\n          ]),\n        ),\n      );\n    case \"CallExpression\":\n      return printCallExpression(\n        needParens,\n        print(true, expression.callee),\n        expression.arguments.map(argument => print(true, argument)),\n      );\n    case \"ConditionalExpression\": {\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            Doc.group(\n              Doc.concat([\n                \"if\",\n                Doc.line,\n                print(false, expression.test),\n                Doc.line,\n                \"then\",\n              ]),\n            ),\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.consequent)]),\n            ),\n            Doc.line,\n            \"else\",\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.alternate)]),\n            ),\n          ]),\n        ),\n      );\n    }\n    case \"Constant\":\n      return JSON.stringify(expression.value);\n    case \"EnumDestruct\": {\n      const {branches, defaultBranch, discriminant, typName} = expression;\n\n      return printMatch(\n        print(false, discriminant),\n        branches.map(({body, names}) => ({\n          body: print(false, body),\n          patterns: names.map(name => ({fields: null, name})),\n        })),\n        defaultBranch && print(false, defaultBranch),\n        typName,\n      );\n    }\n    case \"EnumInstance\":\n      return `${expression.typName}.${expression.instance}`;\n    case \"FunctionExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            Doc.group(\n              Doc.concat([\n                \"fun\",\n                Doc.indent(\n                  Doc.concat([\n                    ...(expression.value.typParameters.length !== 0\n                      ? [\n                          Doc.line,\n                          Typ.printImplicitTyps(expression.value.typParameters),\n                        ]\n                      : []),\n                    printFunArguments(expression.value.arguments),\n                  ]),\n                ),\n                Doc.line,\n                \"=>\",\n              ]),\n            ),\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.value.body)]),\n            ),\n          ]),\n        ),\n      );\n    case \"Let\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(\n            Doc.concat([\n              \"let\",\n              Doc.line,\n              printLeftValue(expression.lval, true),\n              Doc.line,\n              \":=\",\n            ]),\n          ),\n          Doc.indent(Doc.concat([Doc.line, print(false, expression.value)])),\n          Doc.line,\n          \"in\",\n          Doc.hardline,\n          print(false, expression.body),\n        ]),\n      );\n    case \"RecordInstance\":\n      return printRecordInstance(\n        expression.record,\n        expression.fields.map(({name, value}) => ({\n          name,\n          value: print(false, value),\n        })),\n      );\n    case \"RecordProjection\":\n      return Doc.group(\n        Doc.concat([\n          print(true, expression.object),\n          Doc.softline,\n          \".(\",\n          Doc.indent(\n            Doc.group(\n              Doc.concat([\n                Doc.softline,\n                expression.record,\n                \".\",\n                expression.field,\n              ]),\n            ),\n          ),\n          Doc.softline,\n          \")\",\n        ]),\n      );\n    case \"RecordUpdate\":\n      return printCallExpression(\n        needParens,\n        `${expression.record}.set_${expression.field}`,\n        [print(true, expression.object), print(true, expression.update)],\n      );\n    case \"SumDestruct\": {\n      const {branches, defaultBranch, discriminant, sum} = expression;\n\n      return printMatch(\n        print(false, discriminant),\n        branches.map(({body, fields, name}) => ({\n          body: print(false, body),\n          patterns: [{fields, name}],\n        })),\n        defaultBranch && print(false, defaultBranch),\n        sum,\n      );\n    }\n    case \"SumInstance\": {\n      const name = `${expression.sum}.${expression.constr}`;\n\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            name,\n            Doc.line,\n            ...(expression.fields.length !== 0\n              ? [\n                  printRecordInstance(\n                    name,\n                    expression.fields.map(({name, value}) => ({\n                      name,\n                      value: print(false, value),\n                    })),\n                  ),\n                ]\n              : [\"tt\"]),\n          ]),\n        ),\n      );\n    }\n    case \"TypeCastExpression\":\n      return Doc.group(\n        Doc.concat([\n          \"(\",\n          Doc.softline,\n          print(true, expression.expression),\n          Doc.line,\n          \":\",\n          Doc.line,\n          Typ.print(false, expression.typeAnnotation),\n          Doc.softline,\n          \")\",\n        ]),\n      );\n    case \"UnaryExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            expression.operator,\n            Doc.line,\n            print(true, expression.argument),\n          ]),\n        ),\n      );\n    case \"Variable\":\n      return expression.name;\n    /* istanbul ignore next */\n    default:\n      return expression;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Expression from \"./expression.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as Util from \"./util.js\";\n\ntype Constructor = {name: string, fields: {name: string, typ: Typ.t}[]};\n\nexport type t =\n  | {\n      type: \"Enum\",\n      names: string[],\n    }\n  | {\n      type: \"Record\",\n      fields: {name: string, typ: Typ.t}[],\n    }\n  | {\n      type: \"Sum\",\n      constructors: Constructor[],\n    }\n  | {\n      type: \"Synonym\",\n      typ: Typ.t,\n    };\n\nfunction* getObjectTypePropertyName(\n  property: BabelAst.ObjectTypeProperty,\n): Monad.t<string> {\n  return yield* Typ.getObjectKeyName(property.key);\n}\n\nfunction* getStringOfStringLiteralTypeAnnotation(\n  typ: BabelAst.FlowType,\n): Monad.t<string> {\n  switch (typ.type) {\n    case \"StringLiteralTypeAnnotation\":\n      return typ.value;\n    default:\n      return yield* Monad.raise<string>(typ, \"Expected a string literal\");\n  }\n}\n\nfunction* compileStringEnum(typs: BabelAst.FlowType[]): Monad.t<t> {\n  const names = yield* Monad.all(\n    typs.map(function*(typ) {\n      switch (typ.type) {\n        case \"StringLiteralTypeAnnotation\":\n          return typ.value;\n        default:\n          return yield* Monad.raise<string>(\n            typ,\n            \"Only strings are handled in enums\",\n          );\n      }\n    }),\n  );\n\n  return {\n    type: \"Enum\",\n    names,\n  };\n}\n\nfunction* compileSumType(typs: BabelAst.FlowType[]): Monad.t<t> {\n  const constructors = yield* Monad.all(\n    typs.map(function*(typ) {\n      switch (typ.type) {\n        case \"ObjectTypeAnnotation\": {\n          const [nameProperties, fieldProperties] = yield* Monad.reduce(\n            typ.properties,\n            [[], []],\n            function*([nameProperties, fieldProperties], property) {\n              if (property.type !== \"ObjectTypeProperty\") {\n                return yield* Monad.raise<[*, *]>(\n                  property,\n                  \"Expected a named property\",\n                );\n              }\n\n              const name = yield* getObjectTypePropertyName(property);\n\n              return name === \"type\"\n                ? [[...nameProperties, property], fieldProperties]\n                : [nameProperties, [...fieldProperties, property]];\n            },\n          );\n\n          if (nameProperties.length === 0) {\n            return yield* Monad.raise<Constructor>(\n              typ,\n              \"Expected at least one field with the name `type`\",\n            );\n          }\n\n          return {\n            name: yield* getStringOfStringLiteralTypeAnnotation(\n              nameProperties[0].value,\n            ),\n            fields: yield* Monad.all(\n              fieldProperties.map(function*(\n                property: BabelAst.ObjectTypeProperty,\n              ) {\n                return {\n                  name: yield* getObjectTypePropertyName(property),\n                  typ: yield* Typ.compile(property.value),\n                };\n              }),\n            ),\n          };\n        }\n        default:\n          return yield* Monad.raise<Constructor>(\n            typ,\n            \"Only objects are handled in sum types\",\n          );\n      }\n    }),\n  );\n\n  return {\n    type: \"Sum\",\n    constructors,\n  };\n}\n\nexport function* compile(typ: BabelAst.FlowType): Monad.t<t> {\n  const compiledTyp = yield* Typ.compileIfPlainTyp(typ);\n\n  switch (compiledTyp.type) {\n    case \"PlainTyp\":\n      return {\n        type: \"Synonym\",\n        typ: compiledTyp.typ,\n      };\n    case \"Rest\":\n      switch (compiledTyp.typ.type) {\n        case \"ObjectTypeAnnotation\": {\n          const objectTyp = compiledTyp.typ;\n          const withATypeField = yield* Monad.some(\n            objectTyp.properties,\n            function*(property) {\n              switch (property.type) {\n                case \"ObjectTypeProperty\":\n                  return (\n                    (yield* getObjectTypePropertyName(property)) === \"type\"\n                  );\n                default:\n                  return false;\n              }\n            },\n          );\n\n          if (withATypeField) {\n            return yield* compileSumType([objectTyp]);\n          }\n\n          const fields = yield* Monad.all(\n            objectTyp.properties.map(function*(property) {\n              if (property.type !== \"ObjectTypeProperty\") {\n                return yield* Monad.raise(property, \"Expected named property\");\n              }\n\n              return {\n                name: yield* getObjectTypePropertyName(property),\n                typ: yield* Typ.compile(property.value),\n              };\n            }),\n          );\n\n          return {\n            type: \"Record\",\n            fields,\n          };\n        }\n        case \"StringLiteralTypeAnnotation\":\n          return yield* compileStringEnum([compiledTyp.typ]);\n        case \"UnionTypeAnnotation\": {\n          /* istanbul ignore next */\n          if (compiledTyp.typ.types.length === 0) {\n            return {\n              type: \"Synonym\",\n              typ: {\n                type: \"Variable\",\n                name: \"Empty_set\",\n                params: [],\n              },\n            };\n          }\n\n          switch (compiledTyp.typ.types[0].type) {\n            case \"ObjectTypeAnnotation\":\n              return yield* compileSumType(compiledTyp.typ.types);\n            case \"StringLiteralTypeAnnotation\":\n              return yield* compileStringEnum(compiledTyp.typ.types);\n            default:\n              return yield* Monad.raise<t>(\n                compiledTyp.typ,\n                \"Only handle unions of strings or objects with a `type` field\",\n              );\n          }\n        }\n        /* istanbul ignore next */\n        default:\n          return compiledTyp.typ;\n      }\n    /* istanbul ignore next */\n    default:\n      return compiledTyp;\n  }\n}\n\nfunction printModule(name: string, doc: Doc.t): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      Doc.group(Doc.concat([\"Module\", Doc.line, name, \".\"])),\n      Doc.indent(Doc.concat([Doc.hardline, doc])),\n      Doc.group(Doc.concat([Doc.hardline, \"End\", Doc.line, name, \".\"])),\n    ]),\n  );\n}\n\nfunction printRecord(\n  name: string,\n  fields: {name: string, typ: Typ.t}[],\n  withSetters: boolean,\n): Doc.t {\n  return Doc.concat([\n    Doc.group(\n      Doc.concat([\"Record\", Doc.line, \"t\", Doc.line, \":=\", Doc.line, \"{\"]),\n    ),\n    Doc.indent(\n      Doc.concat(\n        fields.map(({name, typ}) =>\n          Doc.concat([\n            Doc.hardline,\n            name,\n            Doc.line,\n            \":\",\n            Doc.line,\n            Typ.print(false, typ),\n            Doc.softline,\n            \";\",\n          ]),\n        ),\n      ),\n    ),\n    Doc.hardline,\n    \"}.\",\n    ...(withSetters\n      ? [\n          Doc.hardline,\n          Doc.join(\n            Doc.hardline,\n            fields.map(({name, typ}) =>\n              Doc.group(\n                Doc.concat([\n                  Doc.group(\n                    Doc.concat([\"Definition\", Doc.line, `set_${name}`]),\n                  ),\n                  Doc.indent(\n                    Doc.group(\n                      Doc.concat([\n                        Doc.line,\n                        \"r\",\n                        Doc.line,\n                        name,\n                        Doc.line,\n                        \":=\",\n                      ]),\n                    ),\n                  ),\n                  Doc.indent(\n                    Doc.concat([\n                      Doc.line,\n                      Expression.printRecordInstance(\n                        null,\n                        fields.map(field => ({\n                          name: field.name,\n                          value:\n                            field.name === name ? name : `r.(${field.name})`,\n                        })),\n                      ),\n                      \".\",\n                    ]),\n                  ),\n                ]),\n              ),\n            ),\n          ),\n        ]\n      : []),\n  ]);\n}\n\nfunction printDefineTypeAsModule(name: string): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"Definition\",\n      Doc.line,\n      name,\n      Doc.line,\n      \":=\",\n      Doc.line,\n      `${name}.t`,\n      \".\",\n    ]),\n  );\n}\n\nexport function print(name: string, typDefinition: t): Doc.t {\n  switch (typDefinition.type) {\n    case \"Enum\": {\n      const module = printModule(\n        name,\n        Doc.concat([\n          Doc.group(Doc.concat([\"Inductive\", Doc.line, \"t\", Doc.line, \":=\"])),\n          ...typDefinition.names.map(name =>\n            Doc.group(Doc.concat([Doc.hardline, \"|\", Doc.line, name])),\n          ),\n          \".\",\n        ]),\n      );\n\n      return Doc.concat([module, Doc.hardline, printDefineTypeAsModule(name)]);\n    }\n    case \"Record\":\n      return Doc.concat([\n        printModule(name, printRecord(\"t\", typDefinition.fields, true)),\n        Doc.hardline,\n        printDefineTypeAsModule(name),\n      ]);\n    case \"Sum\": {\n      const module = printModule(\n        name,\n        Doc.concat([\n          Doc.join(Doc.concat([Doc.hardline, Doc.hardline]), [\n            ...Util.filterMap(typDefinition.constructors, constructor =>\n              constructor.fields.length !== 0\n                ? printModule(\n                    constructor.name,\n                    printRecord(\"t\", constructor.fields, false),\n                  )\n                : null,\n            ),\n            Doc.group(\n              Doc.concat([\n                Doc.group(\n                  Doc.concat([\"Inductive\", Doc.line, \"t\", Doc.line, \":=\"]),\n                ),\n                ...typDefinition.constructors.map(({name, fields}) =>\n                  Doc.group(\n                    Doc.concat([\n                      Doc.hardline,\n                      \"|\",\n                      Doc.line,\n                      name,\n                      Doc.line,\n                      \"(\",\n                      Doc.softline,\n                      \"_\",\n                      Doc.line,\n                      \":\",\n                      Doc.line,\n                      ...(fields.length !== 0 ? [name, \".t\"] : [\"unit\"]),\n                      Doc.softline,\n                      \")\",\n                    ]),\n                  ),\n                ),\n                \".\",\n              ]),\n            ),\n          ]),\n        ]),\n      );\n\n      return Doc.concat([module, Doc.hardline, printDefineTypeAsModule(name)]);\n    }\n    case \"Synonym\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(\n            Doc.concat([\n              \"Definition\",\n              Doc.line,\n              name,\n              Doc.line,\n              \":\",\n              Doc.line,\n              \"Type\",\n              Doc.line,\n              \":=\",\n            ]),\n          ),\n          Doc.indent(\n            Doc.concat([Doc.line, Typ.print(false, typDefinition.typ), \".\"]),\n          ),\n        ]),\n      );\n    /* istanbul ignore next */\n    default:\n      return typDefinition;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Expression from \"./expression.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as TypDefinition from \"./typ-definition.js\";\n\nexport type t =\n  | {\n      type: \"Definition\",\n      arguments: Expression.FunArgument[],\n      body: Expression.t,\n      name: string,\n      returnTyp: ?Typ.t,\n      typParameters: string[],\n    }\n  | {\n      type: \"TypeDefinition\",\n      name: string,\n      typDefinition: TypDefinition.t,\n    };\n\nfunction* extractIdentifierOfLVal(\n  lval: BabelAst.LVal,\n): Monad.t<BabelAst.Identifier> {\n  switch (lval.type) {\n    case \"ArrayPattern\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Array destructuring at top-level is not allowed due to limitations in Coq\",\n      );\n    /* istanbul ignore next */\n    case \"AssignmentPattern\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Unexpected assignement pattern\",\n      );\n    case \"Identifier\":\n      return lval;\n    /* istanbul ignore next */\n    case \"MemberExpression\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Unexpected member expression\",\n      );\n    case \"ObjectPattern\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Object destructuring at top-level is not allowed due to limitations in Coq\",\n      );\n    /* istanbul ignore next */\n    case \"RestElement\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Rest element unexpected outside a pattern\",\n      );\n    /* istanbul ignore next */\n    default:\n      return lval;\n  }\n}\n\nexport function* compile(declaration: BabelAst.Statement): Monad.t<t[]> {\n  switch (declaration.type) {\n    case \"BlockStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Blocks are not handled at top-level\",\n      );\n    // `break` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"BreakStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `break` at top-level\",\n      );\n    case \"ClassDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Class declarations are not handled\",\n      );\n    // `continue` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"ContinueStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `continue` at top-level\",\n      );\n    case \"DebuggerStatement\":\n      return [];\n    case \"DeclareClass\":\n    case \"DeclareExportAllDeclaration\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareVariable\":\n      // We choose to ignore the concept of declaration for now, as we believe\n      // that everything should be public to do proofs.\n      return [];\n    case \"DoWhileStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Do-while loops are not handled\",\n      );\n    case \"EmptyStatement\":\n      return [];\n    case \"ExportAllDeclaration\":\n      return yield* Monad.raise<t[]>(declaration, \"Export all are not handled\");\n    case \"ExportDefaultDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Export default is not handled\",\n      );\n    case \"ExportNamedDeclaration\":\n      return declaration.declaration\n        ? yield* compile(declaration.declaration)\n        : yield* Monad.raise<t[]>(\n            declaration,\n            \"This kind of export is not handled\",\n          );\n    case \"ExpressionStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Top-level expressions are not handled\",\n      );\n    case \"ForInStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"For-in loops are not handled\",\n      );\n    case \"ForOfStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"For-of loops are not handled\",\n      );\n    case \"ForStatement\":\n      return yield* Monad.raise<t[]>(declaration, \"For loops are not handled\");\n    case \"FunctionDeclaration\": {\n      const fun = yield* Expression.compileFun(declaration);\n      const name = declaration.id\n        ? declaration.id.name\n        : // A top-level function always has a name.\n          /* istanbul ignore next */\n          yield* Monad.raise<string>(declaration, \"Expected named function\");\n\n      return [\n        {\n          type: \"Definition\",\n          arguments: fun.arguments,\n          body: fun.body,\n          name,\n          returnTyp: fun.returnTyp,\n          typParameters: fun.typParameters,\n        },\n      ];\n    }\n    case \"IfStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"If at top-level are not handled\",\n      );\n    case \"ImportDeclaration\": {\n      if (declaration.source.value === \"react\") {\n        return [];\n      }\n\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Only the imports from React are handled\",\n      );\n    }\n    case \"InterfaceDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Interface declarations are not handled\",\n      );\n    case \"LabeledStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Labeled statements are not handled\",\n      );\n    case \"OpaqueType\":\n      return [\n        {\n          type: \"TypeDefinition\",\n          name: Identifier.compile(declaration.id),\n          typDefinition: yield* TypDefinition.compile(declaration.impltype),\n        },\n      ];\n    // `return` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"ReturnStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `return` at top-level\",\n      );\n    case \"SwitchStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Top-level switch are not handled\",\n      );\n    case \"ThrowStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Throw statements are not handled\",\n      );\n    case \"TryStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Try statements are not handled\",\n      );\n    case \"TypeAlias\":\n      return [\n        {\n          type: \"TypeDefinition\",\n          name: Identifier.compile(declaration.id),\n          typDefinition: yield* TypDefinition.compile(declaration.right),\n        },\n      ];\n    case \"VariableDeclaration\":\n      return yield* Monad.all(\n        declaration.declarations.map(function*(declaration) {\n          const id = yield* extractIdentifierOfLVal(declaration.id);\n          const returnTyp = id.typeAnnotation\n            ? id.typeAnnotation.typeAnnotation\n            : null;\n\n          return {\n            type: \"Definition\",\n            arguments: [],\n            body: declaration.init\n              ? yield* Expression.compile(declaration.init)\n              : yield* Monad.raise<Expression.t>(\n                  declaration,\n                  \"Expected definition\",\n                ),\n            name: id.name,\n            returnTyp: returnTyp && (yield* Typ.compile(returnTyp)),\n            typParameters: [],\n          };\n        }),\n      );\n    case \"WhileStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"While loops are not handled\",\n      );\n    // The `with` keyword is forbidden as we are in strict mode.\n    /* istanbul ignore next */\n    case \"WithStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"With statements are not handled\",\n      );\n    /* istanbul ignore next */\n    default:\n      return declaration;\n  }\n}\n\nexport function print(declaration: t): Doc.t {\n  switch (declaration.type) {\n    case \"Definition\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(Doc.concat([\"Definition\", Doc.line, declaration.name])),\n          Doc.indent(\n            Doc.concat([\n              ...(declaration.typParameters.length !== 0\n                ? [Doc.line, Typ.printImplicitTyps(declaration.typParameters)]\n                : []),\n              Expression.printFunArguments(declaration.arguments),\n              Doc.line,\n              Typ.printReturnTyp(declaration.returnTyp, \":=\"),\n              Doc.hardline,\n              Expression.print(false, declaration.body),\n              \".\",\n            ]),\n          ),\n        ]),\n      );\n    case \"TypeDefinition\":\n      return TypDefinition.print(declaration.name, declaration.typDefinition);\n    /* istanbul ignore next */\n    default:\n      return declaration;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Monad from \"./monad.js\";\nimport * as TopLevelStatement from \"./top-level-statement.js\";\n\nexport type t = TopLevelStatement.t[];\n\nexport function* compile(program: BabelAst.Program): Monad.t<t> {\n  const unflattenedStatements = yield* Monad.all(\n    program.body.map(statement => TopLevelStatement.compile(statement)),\n  );\n\n  return unflattenedStatements.reduce(\n    (accumulator: t, statements: TopLevelStatement.t[]) => [\n      ...accumulator,\n      ...statements,\n    ],\n    [],\n  );\n}\n\nexport function print(program: t, withHeader: boolean): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      Doc.join(Doc.concat([Doc.hardline, Doc.hardline]), [\n        ...(withHeader\n          ? [\n              `(* Generated by coq-of-js *)\nRequire Import Coq.Lists.List.\nRequire Import Coq.Strings.String.\nRequire Import Coq.ZArith.ZArith.\n\nImport ListNotations.\nLocal Open Scope string.\nLocal Open Scope Z.`,\n            ]\n          : []),\n        ...program.map(programElement =>\n          TopLevelStatement.print(programElement),\n        ),\n      ]),\n      Doc.hardline,\n    ]),\n  );\n}\n","// @flow\n\nexport default `/* Basic definitions */\n\nconst\n  b: boolean = false && true,\n  n: number = -12 + 23;\n\nconst s = \"hi\";\n\nconst a = [1, (2 : number), 3];\n\nconst cond = b ? \"a\" : 'b';\n\n/* Functions */\n\nfunction id<A>(x: A): A {\n  return x;\n}\n\nfunction basicTypes(n: number, m: number): string {\n  return \"OK\";\n}\n\nconst r = id(basicTypes(12, 23));\n\nconst f = function<A> (x : A, y : A): bool {\n  return true;\n}\n\nconst arrow = x => x + 1;\n\n/* Records */\n\ntype Rec = {\n  a: string,\n  b: number,\n  c: boolean\n};\n\nconst o = ({a: \"hi\", b: 12, c: false}: Rec);\n\nconst hi = (o: Rec).a;\n\nconst getHi = (o: Rec) => {\n  const {a: hi}: Rec = o;\n  return hi;\n};\n\n/* Enums */\n\ntype Enum = \"aa\" | \"bb\" | \"gg\";\n\nconst aa = (\"aa\": Enum);\n\nfunction getEnumIndex(e: Enum): number {\n  switch (e /* Enum */) {\n    case \"aa\":\n      return 0;\n    case \"bb\":\n      return 1;\n    default:\n      return 2;\n  }\n}\n\n/* Algebraic data types */\n\ntype Status =\n  | {\n      type: \"Error\",\n      message: string,\n    }\n  | {\n      type: \"Loading\",\n    }\n  | {\n      type: \"Nothing\",\n    };\n\nconst status: Status = ({type: \"Error\", message: \"hi\"}: Status);\n\nfunction getMessage(status: Status): string {\n  switch (status.type /* Status */) {\n    case \"Error\": {\n      const {message} = status;\n      return message;\n    }\n    case \"Loading\":\n      return \"loading...\";\n    case \"Nothing\":\n      return \"\";\n    default:\n      return (status: empty);\n  }\n}\n`;\n","// @flow\nimport React, {PureComponent} from \"react\";\n\ntype Props = {\n  output: string,\n};\n\nexport default class CoqOutput extends PureComponent<Props> {\n  render() {\n    const {output} = this.props;\n\n    return (\n      <code>\n        <pre>{output}</pre>\n      </code>\n    );\n  }\n}\n","// @flow\nimport React, {PureComponent} from \"react\";\nimport codeFrame from \"babel-code-frame\";\nimport {parse} from \"@babel/parser\";\nimport doc from \"prettier/doc.js\";\nimport * as BabelAst from \"./compiler/babel-ast.js\";\nimport * as Error from \"./compiler/error.js\";\nimport * as Monad from \"./compiler/monad.js\";\nimport * as Program from \"./compiler/program.js\";\nimport demoInput from \"./demoInput.js\";\nimport Output from \"./Output.js\";\nimport \"./App.css\";\n\ntype Props = {};\n\ntype State = {\n  jsInput: string,\n};\n\nfunction getInitialJsInput(): string {\n  if (typeof window !== \"undefined\") {\n    const item = window.sessionStorage.getItem(\"jsInput\");\n\n    return typeof item === \"string\" ? item : demoInput;\n  }\n\n  return demoInput;\n}\n\nfunction ExternalLink() {\n  return <svg width=\"13.5\" height=\"13.5\" aria-hidden=\"true\" viewBox=\"0 0 24 24\"><path fill=\"currentColor\" d=\"M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z\"></path></svg>;\n}\n\nexport default class App extends PureComponent<Props, State> {\n  state: State = {\n    jsInput: getInitialJsInput(),\n  };\n\n  onChangeJsInput = (event: SyntheticEvent<HTMLTextAreaElement>) => {\n    const {value} = event.currentTarget;\n\n    this.setState({jsInput: value});\n\n    if (typeof window !== \"undefined\") {\n      window.sessionStorage.setItem(\"jsInput\", value);\n    }\n  };\n\n  getJsAst(jsInput: string): BabelAst.File | string {\n    try {\n      const ast = parse(jsInput, {\n        plugins: [\"flow\", \"jsx\"],\n        sourceType: \"module\",\n      });\n\n      return ast;\n    } catch (error) {\n      const {loc} = error;\n\n      return `${error.message}\\n\\n${codeFrame(jsInput, loc.line, loc.column)}`;\n    }\n  }\n\n  getCoqAst(source: string, jsAst: BabelAst.File): Program.t | string {\n    try {\n      const result = Monad.run(Program.compile(jsAst.program));\n\n      switch (result.type) {\n        case \"Error\":\n          return Error.print(source, result.errors);\n        case \"Success\":\n          return result.value;\n        default:\n          return result;\n      }\n    } catch (error) {\n      return error.message;\n    }\n  }\n\n  getCoqString(coqAst: Program.t): string {\n    return doc.printer.printDocToString(Program.print(coqAst, true), {\n      printWidth: 60,\n      tabWidth: 2,\n    }).formatted;\n  }\n\n  getOutputs(jsInput: string): {coq: string, coqAst: string, jsAst: string} {\n    const jsAst = this.getJsAst(jsInput);\n\n    if (typeof jsAst === \"string\") {\n      return {coq: jsAst, coqAst: \"\", jsAst: \"\"};\n    }\n\n    const coqAst = this.getCoqAst(jsInput, jsAst);\n\n    if (typeof coqAst === \"string\") {\n      return {coq: coqAst, coqAst: \"\", jsAst: \"\"};\n    }\n\n    return {\n      coq: this.getCoqString(coqAst),\n      coqAst: JSON.stringify(coqAst, null, 2),\n      jsAst: JSON.stringify(jsAst, null, 2),\n    };\n  }\n\n  render() {\n    const {jsInput} = this.state;\n    const {coq, coqAst, jsAst} = this.getOutputs(jsInput);\n\n    return (\n      <div>\n        <div className=\"header\">\n          <h1>\n            <span className=\"logo\">\n              <span aria-label=\"globe\" role=\"img\">\n                🌍\n              </span>{\" \"}\n              <span aria-label=\"rooster\" role=\"img\">\n                🐓\n              </span>\n            </span>\n            coq-of-js\n            <span className=\"signature\">by <a href=\"https://formal.land/\" rel=\"noopener noreferrer\" target=\"_blank\">Formal&nbsp;Land&nbsp;🌲&nbsp;<ExternalLink /></a></span>\n            <a\n              className=\"sub-title\"\n              href=\"https://github.com/formal-land/coq-of-js\"\n              rel=\"noopener noreferrer\"\n              target=\"_blank\"\n            >\n              GitHub&nbsp;<ExternalLink />\n            </a>\n          </h1>\n        </div>\n        <div className=\"split js-source\">\n          <h2>🌍 JavaScript editor</h2>\n          <textarea onChange={this.onChangeJsInput} value={jsInput} />\n        </div>\n        <div className=\"split coq-source\">\n          <h2>🐓 Generated Coq</h2>\n          <Output output={coq} />\n        </div>\n        <div className=\"split js-ast\">\n          <h2>🔬 JavaScript AST</h2>\n          <Output output={jsAst} />\n        </div>\n        <div className=\"split coq-ast\">\n          <h2>🔬 Coq AST</h2>\n          <Output output={coqAst} />\n        </div>\n      </div>\n    );\n  }\n}\n","// @flow\nimport {codeFrameColumns} from \"@babel/code-frame\";\nimport * as BabelAst from \"./babel-ast.js\";\n\nexport type t = {\n  location: ?BabelAst.SourceLocation,\n  message: string,\n};\n\nexport function print(source: string, errors: t[]): string {\n  return errors\n    .map(error => {\n      const errorSourceCode = codeFrameColumns(source, error.location);\n\n      return `${errorSourceCode}\\n\\n${error.message}`;\n    })\n    .join(\"\\n\\n**********************\\n\\n\");\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\",\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\",\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\",\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","// @flow\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst rootElement = document.getElementById(\"root\");\n\nif (rootElement) {\n  ReactDOM.render(<App />, rootElement);\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}