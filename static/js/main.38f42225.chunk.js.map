{"version":3,"sources":["compiler/monad.js","compiler/result.js","compiler/doc.js","compiler/identifier.js","compiler/typ.js","compiler/util.js","compiler/expression.js","compiler/typ-definition.js","compiler/top-level-statement.js","compiler/program.js","demoInput.js","Output.js","App.js","compiler/error.js","serviceWorker.js","index.js"],"names":["ret","all","raise","raiseUnhandled","value","expressions","type","reduce","array","accumulator","reducer","a","element","node","message","JSON","stringify","runWithAnswer","expression","answer","result","next","done","nextAnswer","results","errors","Result","map","location","loc","doc","builders","concat","group","hardline","indent","join","line","softline","paren","needParens","nameMapping","Props","compile","identifier","name","compileIdentifier","compileIfHandled","compileIdentifierOrQualifiedTypeIdentifier","id","Identifier","typ","Monad","properties","length","printImplicitTyps","names","Doc","print","filterMap","f","getObjectPropertyName","compileLVal","getStringOfStringLiteral","compileStatements","compileFun","tt","property","key","lval","typeAnnotation","Typ","typName","variable","fields","record","statements","statement","argument","discriminant","cases","branch","consequent","test","body","branches","enum","withDefault","declarations","declaration","slice","init","fun","returnTyp","returnType","params","param","typeParameters","Util","arguments","typParameters","elements","left","operator","right","callee","alternate","computed","constr","sum","instance","printFunArguments","funArguments","printRecordInstance","printLeftValue","getStringOfStringLiteralTypeAnnotation","compileStringEnum","compileSumType","getObjectTypePropertyName","typs","nameProperties","fieldProperties","constructors","plainTyp","some","types","printModule","printRecord","printDefineTypeAsModule","extractIdentifierOfLVal","Expression","source","TypDefinition","impltype","typDefinition","nextToken","module","constructor","program","TopLevelStatement","unflattenedStatements","CoqOutput","output","this","props","PureComponent","getInitialJsInput","window","item","sessionStorage","getItem","demoInput","App","state","jsInput","onChangeJsInput","event","currentTarget","setState","setItem","parse","plugins","sourceType","error","codeFrame","column","jsAst","Program","errorSourceCode","codeFrameColumns","Error","coqAst","printer","printDocToString","programElement","printWidth","tabWidth","formatted","getJsAst","coq","getCoqAst","getCoqString","getOutputs","className","aria-label","role","href","onChange","Boolean","hostname","match","rootElement","document","getElementById","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.38f42225.chunk.js","sourcesContent":["// @flow\n// This monad is used internally by the compiler. It handles the user errors.\n// In contrast to exceptions, it supports one or many errors. Thus the user\n// may get all the errors found by the compiler at once.\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Result from \"./result.js\";\n\ntype Yield =\n  | {\n      type: \"All\",\n      expressions: Generator<Yield, any, any>[],\n    }\n  | {\n      type: \"Raise\",\n      message: string,\n      node: BabelAst.Node,\n    };\n\nexport type t<A> = Generator<Yield, A, any>;\n\n// eslint-disable-next-line require-yield\nexport function* ret<A>(value: A): t<A> {\n  return value;\n}\n\n// Evaluate an array of expressions.\n// Keep all the errors in case there are many.\nexport function* all<A>(expressions: t<A>[]): t<A[]> {\n  return yield {type: \"All\", expressions};\n}\n\nexport function reduce<Accumulator, A>(\n  array: A[],\n  accumulator: Accumulator,\n  reducer: (accumulator: Accumulator, element: A) => t<Accumulator>,\n): t<Accumulator> {\n  return array.reduce(function*(accumulator, element) {\n    return yield* reducer(yield* accumulator, element);\n  }, ret(accumulator));\n}\n\nexport function* raise<A>(node: BabelAst.Node, message: string): t<A> {\n  return yield {type: \"Raise\", message, node};\n}\n\nexport function* raiseUnhandled<A>(node: BabelAst.Node): t<A> {\n  return yield* raise<A>(\n    node,\n    `Unhandled syntax:\\n${JSON.stringify(node, null, 2)}`,\n  );\n}\n\nfunction runWithAnswer<A>(expression: t<A>, answer?: any): Result.t<any> {\n  const result = expression.next(answer);\n\n  if (result.done) {\n    return {\n      type: \"Success\",\n      value: result.value,\n    };\n  }\n\n  const nextAnswer: Result.t<any> = (() => {\n    switch (result.value.type) {\n      case \"All\": {\n        const results = result.value.expressions.map(expression =>\n          runWithAnswer(expression),\n        );\n\n        return Result.merge(results);\n      }\n      case \"Raise\": {\n        const error = {\n          location: result.value.node.loc,\n          message: result.value.message,\n        };\n\n        return {type: \"Error\", errors: [error]};\n      }\n      /* istanbul ignore next */\n      default:\n        return result.value;\n    }\n  })();\n\n  switch (nextAnswer.type) {\n    case \"Error\":\n      return nextAnswer;\n    case \"Success\":\n      return runWithAnswer(expression, nextAnswer.value);\n    /* istanbul ignore next */\n    default:\n      return nextAnswer;\n  }\n}\n\nexport function run<A>(expression: t<A>): Result.t<A> {\n  return runWithAnswer(expression);\n}\n","// @flow\nimport * as Error from \"./error.js\";\n\nexport type t<A> =\n  | {\n      type: \"Error\",\n      errors: Error.t[],\n    }\n  | {\n      type: \"Success\",\n      value: A,\n    };\n\nexport function merge<A>(results: t<A>[]): t<A[]> {\n  return results.reduce(\n    (accumulator: t<A[]>, result: t<A>) => {\n      switch (accumulator.type) {\n        case \"Error\":\n          switch (result.type) {\n            case \"Error\":\n              return {\n                type: \"Error\",\n                errors: [...accumulator.errors, ...result.errors],\n              };\n            case \"Success\":\n              return {\n                type: \"Error\",\n                errors: accumulator.errors,\n              };\n            /* istanbul ignore next */\n            default:\n              return result;\n          }\n        case \"Success\":\n          switch (result.type) {\n            case \"Error\":\n              return {\n                type: \"Error\",\n                errors: result.errors,\n              };\n            case \"Success\":\n              return {\n                type: \"Success\",\n                value: [...accumulator.value, result.value],\n              };\n            /* istanbul ignore next */\n            default:\n              return result;\n          }\n        /* istanbul ignore next */\n        default:\n          return accumulator;\n      }\n    },\n    {type: \"Success\", value: []},\n  );\n}\n","// @flow\n// A wrapper around Prettier doc primitives.\nimport doc from \"prettier/doc.js\";\n\ndeclare opaque type Doc;\n\nexport type t = Doc | string;\n\nconst {\n  concat,\n  group,\n  hardline,\n  indent,\n  join,\n  line,\n  softline,\n}: {\n  concat: (docs: $ReadOnlyArray<t>) => t,\n  group: (doc: t) => t,\n  hardline: t,\n  indent: (doc: t) => t,\n  join: (sep: t, docs: $ReadOnlyArray<t>) => t,\n  line: t,\n  softline: t,\n} = doc.builders;\n\nexport {concat, group, hardline, indent, join, line, softline};\n\nexport function paren(needParens: boolean, doc: t): t {\n  return needParens ? group(concat([\"(\", doc, \")\"])) : doc;\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\n\nconst nameMapping: {[name: string]: string} = {\n  Props: \"_Props\",\n};\n\nexport function compile(identifier: BabelAst.Identifier): string {\n  const {name} = identifier;\n\n  return nameMapping[name] || name;\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\n\nexport type t = {\n  type: \"Variable\",\n  name: string,\n};\n\nfunction compileIdentifierOrQualifiedTypeIdentifier(\n  id: BabelAst.Identifier | BabelAst.QualifiedTypeIdentifier,\n): string {\n  switch (id.type) {\n    case \"Identifier\":\n      return Identifier.compile(id);\n    case \"QualifiedTypeIdentifier\":\n      return Identifier.compile(id.id);\n    /* istanbul ignore next */\n    default:\n      return id;\n  }\n}\n\nexport function* compileIdentifier(typ: BabelAst.FlowType): Monad.t<string> {\n  switch (typ.type) {\n    case \"GenericTypeAnnotation\":\n      return compileIdentifierOrQualifiedTypeIdentifier(typ.id);\n    default:\n      return yield* Monad.raise<string>(typ, \"Expected a type identifier\");\n  }\n}\n\nexport function* compileIfHandled(typ: BabelAst.FlowType): Monad.t<?t> {\n  switch (typ.type) {\n    case \"BooleanLiteralTypeAnnotation\":\n      return yield* Monad.raise<?t>(\n        typ,\n        \"Boolean literals in types are not handled\",\n      );\n    case \"BooleanTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"bool\",\n      };\n    case \"EmptyTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"Empty_set\",\n      };\n    case \"GenericTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: compileIdentifierOrQualifiedTypeIdentifier(typ.id),\n      };\n    case \"NullLiteralTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"unit\",\n      };\n    case \"NumberLiteralTypeAnnotation\":\n      return yield* Monad.raise<?t>(\n        typ,\n        \"Number literals in types are not handled\",\n      );\n    case \"NumberTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"Z\",\n      };\n    case \"ObjectTypeAnnotation\": {\n      if (typ.properties.length === 0) {\n        return {\n          type: \"Variable\",\n          name: \"unit\",\n        };\n      }\n\n      return null;\n    }\n    case \"StringTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"string\",\n      };\n    case \"VoidTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"unit\",\n      };\n    default:\n      return null;\n  }\n}\n\nexport function* compile(typ: BabelAst.FlowType): Monad.t<t> {\n  return (\n    (yield* compileIfHandled(typ)) || (yield* Monad.raiseUnhandled<t>(typ))\n  );\n}\n\nexport function printImplicitTyps(names: string[]): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"{\",\n      Doc.indent(\n        Doc.concat([\n          Doc.softline,\n          Doc.join(Doc.line, names),\n          Doc.line,\n          Doc.group(Doc.concat([\":\", Doc.line, \"Type\"])),\n        ]),\n      ),\n      Doc.softline,\n      \"}\",\n    ]),\n  );\n}\n\nexport function print(typ: t): Doc.t {\n  switch (typ.type) {\n    case \"Variable\":\n      return typ.name;\n    /* istanbul ignore next */\n    default:\n      return typ;\n  }\n}\n\nexport function printReturnTyp(typ: ?t, nextToken: Doc.t): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      ...(typ ? [\":\", Doc.line, print(typ), Doc.line] : []),\n      nextToken,\n    ]),\n  );\n}\n","// @flow\n\nexport function filterMap<A, B>(array: A[], f: (element: A) => ?B): B[] {\n  return array.reduce((accumulator: B[], element) => {\n    const result = f(element);\n\n    return result ? [...accumulator, result] : accumulator;\n  }, []);\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as Util from \"./util.js\";\n\ntype LeftValueRecordField = {\n  name: string,\n  variable: string,\n};\n\ntype LeftValue =\n  | {\n      type: \"Record\",\n      fields: LeftValueRecordField[],\n      record: string,\n    }\n  | {\n      type: \"Variable\",\n      name: string,\n    };\n\nexport type t =\n  | {\n      type: \"ArrayExpression\",\n      elements: t[],\n    }\n  | {\n      type: \"BinaryExpression\",\n      left: t,\n      operator: string,\n      right: t,\n    }\n  | {\n      type: \"CallExpression\",\n      arguments: t[],\n      callee: t,\n    }\n  | {\n      type: \"ConditionalExpression\",\n      alternate: t,\n      consequent: t,\n      test: t,\n    }\n  | {\n      type: \"Constant\",\n      value: boolean | number | string,\n    }\n  | {\n      type: \"EnumDestruct\",\n      branches: {body: t, name: string}[],\n      discriminant: t,\n      enum: string,\n      withDefault: boolean,\n    }\n  | {\n      type: \"EnumInstance\",\n      enum: string,\n      instance: string,\n    }\n  | {\n      type: \"FunctionExpression\",\n      // eslint-disable-next-line no-use-before-define\n      value: Fun,\n    }\n  | {\n      type: \"Let\",\n      body: t,\n      lval: LeftValue,\n      value: t,\n    }\n  | {\n      type: \"RecordInstance\",\n      // eslint-disable-next-line no-use-before-define\n      fields: RecordField[],\n      record: string,\n    }\n  | {\n      type: \"SumInstance\",\n      constr: string,\n      // eslint-disable-next-line no-use-before-define\n      fields: RecordField[],\n      sum: string,\n    }\n  | {\n      type: \"TypeCastExpression\",\n      expression: t,\n      typeAnnotation: Typ.t,\n    }\n  | {\n      type: \"UnaryExpression\",\n      argument: t,\n      operator: string,\n    }\n  | {\n      type: \"Variable\",\n      name: string,\n    };\n\nexport type FunArgument = {\n  name: string,\n  typ: ?Typ.t,\n};\n\nexport type Fun = {\n  arguments: FunArgument[],\n  body: t,\n  returnTyp: ?Typ.t,\n  typParameters: string[],\n};\n\ntype RecordField = {\n  name: string,\n  value: t,\n};\n\nexport const tt: t = {\n  type: \"Variable\",\n  name: \"tt\",\n};\n\nfunction* getObjectPropertyName(\n  property: BabelAst.ObjectProperty,\n): Monad.t<string> {\n  switch (property.key.type) {\n    case \"Identifier\":\n      return Identifier.compile(property.key);\n    case \"StringLiteral\":\n      return property.key.value;\n    default:\n      return yield* Monad.raise<string>(\n        property,\n        \"Expected a plain string as identifier\",\n      );\n  }\n}\n\nfunction* compileLVal(lval: BabelAst.LVal): Monad.t<LeftValue> {\n  switch (lval.type) {\n    case \"Identifier\":\n      return {\n        type: \"Variable\",\n        name: Identifier.compile(lval),\n      };\n    case \"ObjectPattern\": {\n      const typName = lval.typeAnnotation\n        ? yield* Typ.compileIdentifier(lval.typeAnnotation.typeAnnotation)\n        : yield* Monad.raise<string>(\n            lval,\n            \"Expected a type annotation for the destructuring\",\n          );\n      const fields = yield* Monad.all(\n        lval.properties.map(function*(property) {\n          switch (property.type) {\n            case \"ObjectProperty\":\n              switch (property.value.type) {\n                case \"Identifier\": {\n                  const {value} = property;\n\n                  return {\n                    name: yield* getObjectPropertyName(property),\n                    variable: Identifier.compile(value),\n                  };\n                }\n                default:\n                  return yield* Monad.raise<LeftValueRecordField>(\n                    property.value,\n                    \"Expected an identifier\",\n                  );\n              }\n            default:\n              return yield* Monad.raise<LeftValueRecordField>(\n                property,\n                \"Unhandled pattern field\",\n              );\n          }\n        }),\n      );\n\n      return {\n        type: \"Record\",\n        fields,\n        record: typName,\n      };\n    }\n    default:\n      return yield* Monad.raise<LeftValue>(lval, \"Unhandled left value\");\n  }\n}\n\nfunction* getStringOfStringLiteral(\n  expression: BabelAst.Expression,\n): Monad.t<string> {\n  switch (expression.type) {\n    case \"StringLiteral\":\n      return expression.value;\n    default:\n      return yield* Monad.raise<string>(\n        expression,\n        \"Expected a string literal\",\n      );\n  }\n}\n\nexport function* compileStatements(\n  statements: BabelAst.Statement[],\n): Monad.t<t> {\n  if (statements.length === 0) {\n    return tt;\n  }\n\n  const statement = statements[0];\n\n  switch (statement.type) {\n    case \"ReturnStatement\":\n      return statement.argument ? yield* compile(statement.argument) : tt;\n    case \"SwitchStatement\":\n      switch (statement.discriminant.type) {\n        case \"TypeCastExpression\": {\n          const {expression, typeAnnotation} = statement.discriminant;\n\n          return {\n            type: \"EnumDestruct\",\n            branches: yield* Monad.all(\n              statement.cases.map(function*(branch) {\n                return {\n                  body: yield* compileStatements(branch.consequent),\n                  name: branch.test\n                    ? yield* getStringOfStringLiteral(branch.test)\n                    : yield* Monad.raise<string>(\n                        branch,\n                        \"Unhandled default case\",\n                      ),\n                };\n              }),\n            ),\n            discriminant: yield* compile(expression),\n            enum: yield* Typ.compileIdentifier(typeAnnotation.typeAnnotation),\n            withDefault: false,\n          };\n        }\n        default:\n          return yield* Monad.raise<t>(\n            statement.discriminant,\n            \"Missing type annotation\",\n          );\n      }\n    case \"VariableDeclaration\": {\n      if (statement.declarations.length !== 1) {\n        return yield* Monad.raise<t>(\n          statement,\n          \"Expected exactly one definition\",\n        );\n      }\n\n      const declaration = statement.declarations[0];\n\n      return {\n        type: \"Let\",\n        body: yield* compileStatements(statements.slice(1)),\n        lval: yield* compileLVal(declaration.id),\n        value: declaration.init\n          ? yield* compile(declaration.init)\n          : yield* Monad.raise<t>(declaration, \"Expected definition\"),\n      };\n    }\n    default:\n      return yield* Monad.raiseUnhandled<t>(statement);\n  }\n}\n\nexport function* compileFun(\n  fun:\n    | BabelAst.FunctionDeclaration\n    | BabelAst.FunctionExpression\n    | BabelAst.ArrowFunctionExpression,\n): Monad.t<Fun> {\n  const returnTyp = fun.returnType ? fun.returnType.typeAnnotation : null;\n\n  return {\n    arguments: yield* Monad.all(\n      fun.params.map(function*(param) {\n        switch (param.type) {\n          case \"Identifier\":\n            return {\n              name: param.name,\n              typ: param.typeAnnotation\n                ? yield* Typ.compile(param.typeAnnotation.typeAnnotation)\n                : null,\n            };\n          default:\n            return yield* Monad.raise<FunArgument>(\n              param,\n              \"Expected simple identifier as function parameter\",\n            );\n        }\n      }),\n    ),\n    body:\n      fun.body.type === \"BlockStatement\"\n        ? yield* compileStatements(fun.body.body)\n        : yield* compile(fun.body),\n    returnTyp: returnTyp && (yield* Typ.compile(returnTyp)),\n    typParameters: fun.typeParameters\n      ? Util.filterMap(fun.typeParameters.params, param => param.name)\n      : [],\n  };\n}\n\nexport function* compile(expression: BabelAst.Expression): Monad.t<t> {\n  switch (expression.type) {\n    case \"ArrayExpression\":\n      return {\n        type: \"ArrayExpression\",\n        elements: expression.elements\n          ? yield* Monad.all(\n              expression.elements.map(function*(element) {\n                if (!element) {\n                  return yield* Monad.raise<t>(\n                    expression,\n                    \"Expected non-empty elements in the array\",\n                  );\n                }\n\n                if (element.type === \"SpreadElement\") {\n                  return yield* Monad.raise<t>(\n                    element,\n                    \"Spreads in arrays are not handled\",\n                  );\n                }\n\n                return yield* compile(element);\n              }),\n            )\n          : yield* Monad.raise<t[]>(expression, \"Expected an array expression\"),\n      };\n    case \"ArrowFunctionExpression\":\n      return {\n        type: \"FunctionExpression\",\n        value: yield* compileFun(expression),\n      };\n    case \"BinaryExpression\":\n      return {\n        type: \"BinaryExpression\",\n        left: yield* compile(expression.left),\n        operator: expression.operator,\n        right: yield* compile(expression.right),\n      };\n    case \"BooleanLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"CallExpression\":\n      return {\n        type: \"CallExpression\",\n        arguments: yield* Monad.all(\n          expression.arguments.map(function*(argument) {\n            switch (argument.type) {\n              case \"ArgumentPlaceholder\":\n              case \"JSXNamespacedName\":\n              case \"SpreadElement\":\n                return yield* Monad.raise<t>(\n                  argument,\n                  \"Unhandled function argument\",\n                );\n              default:\n                return yield* compile(argument);\n            }\n          }),\n        ),\n        callee: yield* compile(expression.callee),\n      };\n    case \"ConditionalExpression\":\n      return {\n        type: \"ConditionalExpression\",\n        alternate: yield* compile(expression.alternate),\n        consequent: yield* compile(expression.consequent),\n        test: yield* compile(expression.test),\n      };\n    case \"FunctionExpression\":\n      return {\n        type: \"FunctionExpression\",\n        value: yield* compileFun(expression),\n      };\n    case \"Identifier\":\n      return {\n        type: \"Variable\",\n        name: expression.name,\n      };\n    case \"LogicalExpression\":\n      return {\n        type: \"BinaryExpression\",\n        left: yield* compile(expression.left),\n        operator: expression.operator,\n        right: yield* compile(expression.right),\n      };\n    case \"NullLiteral\":\n      return tt;\n    case \"NumericLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"ObjectExpression\": {\n      if (expression.properties.length === 0) {\n        return tt;\n      }\n\n      return yield* Monad.raise<t>(\n        expression,\n        \"Unhandled object expression without type annotation\",\n      );\n    }\n    case \"ParenthesizedExpression\":\n      return yield* compile(expression.expression);\n    case \"StringLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"TypeCastExpression\": {\n      switch (expression.expression.type) {\n        case \"ObjectExpression\": {\n          const [names, fields] = yield* Monad.reduce(\n            expression.expression.properties,\n            [[], []],\n            function*([names, fields], property) {\n              if (property.type !== \"ObjectProperty\") {\n                return yield* Monad.raise<[*, *]>(\n                  property,\n                  \"Expected a named property\",\n                );\n              }\n\n              if (property.computed) {\n                return yield* Monad.raise<[*, *]>(\n                  property.key,\n                  \"Unhandled computed property name\",\n                );\n              }\n\n              const name = yield* getObjectPropertyName(property);\n              // Because this seems to be the case here and for\n              // performance reasons for the type checking.\n              const value: BabelAst.Expression = (property.value: any);\n\n              if (name === \"type\") {\n                return [\n                  [...names, yield* getStringOfStringLiteral(value)],\n                  fields,\n                ];\n              }\n\n              return [names, [...fields, {name, value: yield* compile(value)}]];\n            },\n          );\n          const typName = yield* Typ.compileIdentifier(\n            expression.typeAnnotation.typeAnnotation,\n          );\n\n          return names.length === 0\n            ? {type: \"RecordInstance\", record: typName, fields}\n            : {\n                type: \"SumInstance\",\n                constr: names[0],\n                fields,\n                sum: typName,\n              };\n        }\n        case \"StringLiteral\": {\n          const {value} = expression.expression;\n\n          return {\n            type: \"EnumInstance\",\n            enum: yield* Typ.compileIdentifier(\n              expression.typeAnnotation.typeAnnotation,\n            ),\n            instance: value,\n          };\n        }\n        default:\n          return {\n            type: \"TypeCastExpression\",\n            expression: yield* compile(expression.expression),\n            typeAnnotation: yield* Typ.compile(\n              expression.typeAnnotation.typeAnnotation,\n            ),\n          };\n      }\n    }\n    case \"UnaryExpression\":\n      return {\n        type: \"UnaryExpression\",\n        argument: yield* compile(expression.argument),\n        operator: expression.operator,\n      };\n    default:\n      return yield* Monad.raiseUnhandled<t>(expression);\n  }\n}\n\nexport function printFunArguments(funArguments: FunArgument[]): Doc.t {\n  return Doc.concat(\n    funArguments.map(({name, typ}) =>\n      Doc.concat([\n        Doc.line,\n        typ\n          ? Doc.group(\n              Doc.concat([\n                \"(\",\n                name,\n                Doc.line,\n                \":\",\n                Doc.line,\n                Typ.print(typ),\n                \")\",\n              ]),\n            )\n          : name,\n      ]),\n    ),\n  );\n}\n\nfunction printRecordInstance(\n  record: string,\n  fields: {name: string, value: Doc.t}[],\n): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"{|\",\n      Doc.indent(\n        Doc.concat(\n          fields.map(({name, value}) =>\n            Doc.concat([\n              Doc.line,\n              Doc.group(\n                Doc.concat([\n                  Doc.group(Doc.concat([`${record}.${name}`, Doc.line, \":=\"])),\n                  Doc.indent(Doc.concat([Doc.line, value, \";\"])),\n                ]),\n              ),\n            ]),\n          ),\n        ),\n      ),\n      Doc.line,\n      \"|}\",\n    ]),\n  );\n}\n\nfunction printLeftValue(lval: LeftValue): Doc.t {\n  switch (lval.type) {\n    case \"Record\":\n      return Doc.concat([\n        \"'\",\n        printRecordInstance(\n          lval.record,\n          lval.fields.map(({name, variable}) => ({name, value: variable})),\n        ),\n      ]);\n    case \"Variable\":\n      return lval.name;\n    /* istanbul ignore next */\n    default:\n      return lval;\n  }\n}\n\nexport function print(needParens: boolean, expression: t): Doc.t {\n  switch (expression.type) {\n    case \"ArrayExpression\":\n      if (expression.elements.length === 0) {\n        return \"[]\";\n      }\n\n      return Doc.group(\n        Doc.concat([\n          \"[\",\n          Doc.indent(\n            Doc.concat([\n              Doc.line,\n              Doc.join(\n                Doc.concat([\",\", Doc.line]),\n                expression.elements.map(element => print(false, element)),\n              ),\n            ]),\n          ),\n          Doc.line,\n          \"]\",\n        ]),\n      );\n    case \"BinaryExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.join(Doc.line, [\n            print(true, expression.left),\n            expression.operator,\n            print(true, expression.right),\n          ]),\n        ),\n      );\n    case \"CallExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.indent(\n            Doc.join(Doc.line, [\n              print(true, expression.callee),\n              ...expression.arguments.map(argument => print(true, argument)),\n            ]),\n          ),\n        ),\n      );\n    case \"ConditionalExpression\": {\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            Doc.group(\n              Doc.concat([\n                \"if\",\n                Doc.line,\n                print(false, expression.test),\n                Doc.line,\n                \"then\",\n              ]),\n            ),\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.consequent)]),\n            ),\n            Doc.line,\n            \"else\",\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.alternate)]),\n            ),\n          ]),\n        ),\n      );\n    }\n    case \"Constant\":\n      return JSON.stringify(expression.value);\n    case \"EnumDestruct\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(\n            Doc.concat([\n              \"match\",\n              Doc.line,\n              print(false, expression.discriminant),\n              Doc.line,\n              \"with\",\n            ]),\n          ),\n          Doc.hardline,\n          ...expression.branches.map(({body, name}) =>\n            Doc.group(\n              Doc.concat([\n                \"|\",\n                Doc.line,\n                `${expression.enum}.${name}`,\n                Doc.line,\n                \"=>\",\n                Doc.line,\n                print(false, body),\n                Doc.hardline,\n              ]),\n            ),\n          ),\n          \"end\",\n        ]),\n      );\n    case \"EnumInstance\":\n      return `${expression.enum}.${expression.instance}`;\n    case \"FunctionExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            Doc.group(\n              Doc.concat([\n                \"fun\",\n                Doc.indent(\n                  Doc.concat([\n                    ...(expression.value.typParameters.length !== 0\n                      ? [\n                          Doc.line,\n                          Typ.printImplicitTyps(expression.value.typParameters),\n                        ]\n                      : []),\n                    printFunArguments(expression.value.arguments),\n                  ]),\n                ),\n                Doc.line,\n                \"=>\",\n              ]),\n            ),\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.value.body)]),\n            ),\n          ]),\n        ),\n      );\n    case \"Let\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(\n            Doc.concat([\n              \"let\",\n              Doc.line,\n              printLeftValue(expression.lval),\n              Doc.line,\n              \":=\",\n            ]),\n          ),\n          Doc.indent(Doc.concat([Doc.line, print(false, expression.value)])),\n          Doc.line,\n          \"in\",\n          Doc.hardline,\n          print(false, expression.body),\n        ]),\n      );\n    case \"RecordInstance\":\n      return printRecordInstance(\n        expression.record,\n        expression.fields.map(({name, value}) => ({\n          name,\n          value: print(false, value),\n        })),\n      );\n    case \"SumInstance\": {\n      const name = `${expression.sum}.${expression.constr}`;\n\n      if (expression.fields.length === 0) {\n        return name;\n      }\n\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            name,\n            Doc.line,\n            printRecordInstance(\n              name,\n              expression.fields.map(({name, value}) => ({\n                name,\n                value: print(false, value),\n              })),\n            ),\n          ]),\n        ),\n      );\n    }\n    case \"TypeCastExpression\":\n      return Doc.group(\n        Doc.concat([\n          \"(\",\n          Doc.softline,\n          print(true, expression.expression),\n          Doc.line,\n          \":\",\n          Doc.line,\n          Typ.print(expression.typeAnnotation),\n          Doc.softline,\n          \")\",\n        ]),\n      );\n    case \"UnaryExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            expression.operator,\n            Doc.line,\n            print(true, expression.argument),\n          ]),\n        ),\n      );\n    case \"Variable\":\n      return expression.name;\n    /* istanbul ignore next */\n    default:\n      return expression;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as Util from \"./util.js\";\n\ntype Constructor = {name: string, fields: {name: string, typ: Typ.t}[]};\n\nexport type t =\n  | {\n      type: \"Enum\",\n      names: string[],\n    }\n  | {\n      type: \"Record\",\n      fields: {name: string, typ: Typ.t}[],\n    }\n  | {\n      type: \"Sum\",\n      constructors: Constructor[],\n    }\n  | {\n      type: \"Synonym\",\n      typ: Typ.t,\n    };\n\nexport function getObjectTypePropertyName(\n  property: BabelAst.ObjectTypeProperty,\n): string {\n  switch (property.key.type) {\n    case \"Identifier\":\n      return Identifier.compile(property.key);\n    case \"StringLiteral\":\n      return property.key.value;\n    /* istanbul ignore next */\n    default:\n      return property.key;\n  }\n}\n\nfunction* getStringOfStringLiteralTypeAnnotation(\n  typ: BabelAst.FlowType,\n): Monad.t<string> {\n  switch (typ.type) {\n    case \"StringLiteralTypeAnnotation\":\n      return typ.value;\n    default:\n      return yield* Monad.raise<string>(typ, \"Expected a string literal\");\n  }\n}\n\nfunction* compileStringEnum(typs: BabelAst.FlowType[]): Monad.t<t> {\n  const names = yield* Monad.all(\n    typs.map(function*(typ) {\n      switch (typ.type) {\n        case \"StringLiteralTypeAnnotation\":\n          return typ.value;\n        default:\n          return yield* Monad.raise<string>(\n            typ,\n            \"Only strings are handled in enums\",\n          );\n      }\n    }),\n  );\n\n  return {\n    type: \"Enum\",\n    names,\n  };\n}\n\nfunction* compileSumType(typs: BabelAst.FlowType[]): Monad.t<t> {\n  const constructors = yield* Monad.all(\n    typs.map(function*(typ) {\n      switch (typ.type) {\n        case \"ObjectTypeAnnotation\": {\n          const [nameProperties, fieldProperties] = yield* Monad.reduce(\n            typ.properties,\n            [[], []],\n            function*([nameProperties, fieldProperties], property) {\n              if (property.type !== \"ObjectTypeProperty\") {\n                return yield* Monad.raise<[*, *]>(\n                  property,\n                  \"Expected a named property\",\n                );\n              }\n\n              const name = getObjectTypePropertyName(property);\n\n              return name === \"type\"\n                ? [[...nameProperties, property], fieldProperties]\n                : [nameProperties, [...fieldProperties, property]];\n            },\n          );\n\n          if (nameProperties.length === 0) {\n            return yield* Monad.raise<Constructor>(\n              typ,\n              \"Expected at least one field with the name `type`\",\n            );\n          }\n\n          return {\n            name: yield* getStringOfStringLiteralTypeAnnotation(\n              nameProperties[0].value,\n            ),\n            fields: yield* Monad.all(\n              fieldProperties.map(function*(\n                property: BabelAst.ObjectTypeProperty,\n              ) {\n                return {\n                  name: getObjectTypePropertyName(property),\n                  typ: yield* Typ.compile(property.value),\n                };\n              }),\n            ),\n          };\n        }\n        default:\n          return yield* Monad.raise<Constructor>(\n            typ,\n            \"Only objects are handled in sum types\",\n          );\n      }\n    }),\n  );\n\n  return {\n    type: \"Sum\",\n    constructors,\n  };\n}\n\nexport function* compile(typ: BabelAst.FlowType): Monad.t<t> {\n  const plainTyp = yield* Typ.compileIfHandled(typ);\n\n  if (plainTyp) {\n    return {\n      type: \"Synonym\",\n      typ: plainTyp,\n    };\n  }\n\n  switch (typ.type) {\n    case \"ObjectTypeAnnotation\": {\n      const withATypeField = typ.properties.some(\n        property =>\n          property.type === \"ObjectTypeProperty\" &&\n          getObjectTypePropertyName(property) === \"type\",\n      );\n\n      if (withATypeField) {\n        return yield* compileSumType([typ]);\n      }\n\n      const fields = yield* Monad.all(\n        typ.properties.map(function*(property) {\n          if (property.type !== \"ObjectTypeProperty\") {\n            return yield* Monad.raise(property, \"Expected named property\");\n          }\n\n          return {\n            name: getObjectTypePropertyName(property),\n            typ: yield* Typ.compile(property.value),\n          };\n        }),\n      );\n\n      return {\n        type: \"Record\",\n        fields,\n      };\n    }\n    case \"StringLiteralTypeAnnotation\":\n      return yield* compileStringEnum([typ]);\n    case \"UnionTypeAnnotation\": {\n      if (typ.types.length === 0) {\n        return {\n          type: \"Synonym\",\n          typ: {\n            type: \"Variable\",\n            name: \"Empty_set\",\n          },\n        };\n      }\n\n      switch (typ.types[0].type) {\n        case \"ObjectTypeAnnotation\":\n          return yield* compileSumType(typ.types);\n        case \"StringLiteralTypeAnnotation\":\n          return yield* compileStringEnum(typ.types);\n        default:\n          return yield* Monad.raise<t>(\n            typ,\n            \"Only handle unions of strings or objects with a `type` field\",\n          );\n      }\n    }\n    default:\n      return yield* Monad.raiseUnhandled<t>(typ);\n  }\n}\n\nfunction printModule(name: string, doc: Doc.t): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      Doc.group(Doc.concat([\"Module\", Doc.line, name, \".\"])),\n      Doc.indent(Doc.concat([Doc.hardline, doc])),\n      Doc.group(Doc.concat([Doc.hardline, \"End\", Doc.line, name, \".\"])),\n    ]),\n  );\n}\n\nfunction printRecord(\n  name: string,\n  fields: {name: string, typ: Typ.t}[],\n): Doc.t {\n  return Doc.concat([\n    Doc.group(\n      Doc.concat([\"Record\", Doc.line, \"t\", Doc.line, \":=\", Doc.line, \"{\"]),\n    ),\n    Doc.indent(\n      Doc.concat(\n        fields.map(({name, typ}) =>\n          Doc.concat([\n            Doc.hardline,\n            name,\n            Doc.line,\n            \":\",\n            Doc.line,\n            Typ.print(typ),\n            Doc.softline,\n            \";\",\n          ]),\n        ),\n      ),\n    ),\n    Doc.hardline,\n    \"}.\",\n  ]);\n}\n\nfunction printDefineTypeAsModule(name: string): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"Definition\",\n      Doc.line,\n      name,\n      Doc.line,\n      \":=\",\n      Doc.line,\n      `${name}.t`,\n      \".\",\n    ]),\n  );\n}\n\nexport function print(name: string, typDefinition: t): Doc.t {\n  switch (typDefinition.type) {\n    case \"Enum\": {\n      const module = printModule(\n        name,\n        Doc.concat([\n          Doc.group(Doc.concat([\"Inductive\", Doc.line, \"t\", Doc.line, \":=\"])),\n          ...typDefinition.names.map(name =>\n            Doc.group(Doc.concat([Doc.hardline, \"|\", Doc.line, name])),\n          ),\n          \".\",\n        ]),\n      );\n\n      return Doc.concat([module, Doc.hardline, printDefineTypeAsModule(name)]);\n    }\n    case \"Record\":\n      return Doc.concat([\n        printModule(name, printRecord(\"t\", typDefinition.fields)),\n        Doc.hardline,\n        printDefineTypeAsModule(name),\n      ]);\n    case \"Sum\": {\n      const module = printModule(\n        name,\n        Doc.concat([\n          Doc.join(Doc.concat([Doc.hardline, Doc.hardline]), [\n            ...Util.filterMap(typDefinition.constructors, constructor =>\n              constructor.fields.length !== 0\n                ? printModule(\n                    constructor.name,\n                    printRecord(\"t\", constructor.fields),\n                  )\n                : null,\n            ),\n            Doc.group(\n              Doc.concat([\n                Doc.group(\n                  Doc.concat([\"Inductive\", Doc.line, \"t\", Doc.line, \":=\"]),\n                ),\n                ...typDefinition.constructors.map(({name, fields}) =>\n                  Doc.group(\n                    Doc.concat([\n                      Doc.hardline,\n                      \"|\",\n                      Doc.line,\n                      name,\n                      ...(fields.length !== 0\n                        ? [\n                            Doc.line,\n                            \"(\",\n                            Doc.softline,\n                            \"_\",\n                            Doc.line,\n                            \":\",\n                            Doc.line,\n                            name,\n                            \".t\",\n                            Doc.softline,\n                            \")\",\n                          ]\n                        : []),\n                    ]),\n                  ),\n                ),\n                \".\",\n              ]),\n            ),\n          ]),\n        ]),\n      );\n\n      return Doc.concat([module, Doc.hardline, printDefineTypeAsModule(name)]);\n    }\n    case \"Synonym\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(\n            Doc.concat([\n              \"Definition\",\n              Doc.line,\n              name,\n              Doc.line,\n              \":\",\n              Doc.line,\n              \"Type\",\n              Doc.line,\n              \":=\",\n            ]),\n          ),\n          Doc.indent(Doc.concat([Doc.line, Typ.print(typDefinition.typ), \".\"])),\n        ]),\n      );\n    /* istanbul ignore next */\n    default:\n      return typDefinition;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Expression from \"./expression.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as TypDefinition from \"./typ-definition.js\";\n\nexport type t =\n  | {\n      type: \"Definition\",\n      arguments: Expression.FunArgument[],\n      body: Expression.t,\n      name: string,\n      returnTyp: ?Typ.t,\n      typParameters: string[],\n    }\n  | {\n      type: \"TypeDefinition\",\n      name: string,\n      typDefinition: TypDefinition.t,\n    };\n\nfunction* extractIdentifierOfLVal(\n  lval: BabelAst.LVal,\n): Monad.t<BabelAst.Identifier> {\n  switch (lval.type) {\n    case \"Identifier\":\n      return lval;\n    default:\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Expected simple identifier\",\n      );\n  }\n}\n\nexport function* compile(declaration: BabelAst.Statement): Monad.t<t[]> {\n  switch (declaration.type) {\n    case \"BlockStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Blocks are not handled at top-level\",\n      );\n    // `break` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"BreakStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `break` at top-level\",\n      );\n    case \"ClassDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Class declarations are not handled\",\n      );\n    // `continue` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"ContinueStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `continue` at top-level\",\n      );\n    case \"DebuggerStatement\":\n      return [];\n    case \"DeclareClass\":\n    case \"DeclareExportAllDeclaration\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareVariable\":\n      // We choose to ignore the concept of declaration for now, as we believe\n      // that everything should be public to do proofs.\n      return [];\n    case \"DoWhileStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Do-while loops are not handled\",\n      );\n    case \"EmptyStatement\":\n      return [];\n    case \"ExportAllDeclaration\":\n      return yield* Monad.raise<t[]>(declaration, \"Export all are not handled\");\n    case \"ExportDefaultDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Export default is not handled\",\n      );\n    case \"ExportNamedDeclaration\":\n      return declaration.declaration\n        ? yield* compile(declaration.declaration)\n        : yield* Monad.raise<t[]>(\n            declaration,\n            \"This kind of export is not handled\",\n          );\n    case \"ExpressionStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Top-level expressions are not handled\",\n      );\n    case \"ForInStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"For-in loops are not handled\",\n      );\n    case \"ForOfStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"For-of loops are not handled\",\n      );\n    case \"ForStatement\":\n      return yield* Monad.raise<t[]>(declaration, \"For loops are not handled\");\n    case \"FunctionDeclaration\": {\n      const fun = yield* Expression.compileFun(declaration);\n      const name = declaration.id\n        ? declaration.id.name\n        : // A top-level function always has a name.\n          /* istanbul ignore next */\n          yield* Monad.raise<string>(declaration, \"Expected named function\");\n\n      return [\n        {\n          type: \"Definition\",\n          arguments: fun.arguments,\n          body: fun.body,\n          name,\n          returnTyp: fun.returnTyp,\n          typParameters: fun.typParameters,\n        },\n      ];\n    }\n    case \"IfStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"If at top-level are not handled\",\n      );\n    case \"ImportDeclaration\": {\n      if (declaration.source.value === \"react\") {\n        return [];\n      }\n\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Only the imports from React are handled\",\n      );\n    }\n    case \"InterfaceDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Interface declarations are not handled\",\n      );\n    case \"LabeledStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Labeled statements are not handled\",\n      );\n    case \"OpaqueType\":\n      return [\n        {\n          type: \"TypeDefinition\",\n          name: Identifier.compile(declaration.id),\n          typDefinition: yield* TypDefinition.compile(declaration.impltype),\n        },\n      ];\n    // `return` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"ReturnStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `return` at top-level\",\n      );\n    case \"SwitchStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Top-level switch are not handled\",\n      );\n    case \"ThrowStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Throw statements are not handled\",\n      );\n    case \"TryStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Try statements are not handled\",\n      );\n    case \"TypeAlias\":\n      return [\n        {\n          type: \"TypeDefinition\",\n          name: Identifier.compile(declaration.id),\n          typDefinition: yield* TypDefinition.compile(declaration.right),\n        },\n      ];\n    case \"VariableDeclaration\":\n      return yield* Monad.all(\n        declaration.declarations.map(function*(declaration) {\n          const id = yield* extractIdentifierOfLVal(declaration.id);\n          const returnTyp = id.typeAnnotation\n            ? id.typeAnnotation.typeAnnotation\n            : null;\n\n          return {\n            type: \"Definition\",\n            arguments: [],\n            body: declaration.init\n              ? yield* Expression.compile(declaration.init)\n              : yield* Monad.raise<Expression.t>(\n                  declaration,\n                  \"Expected definition\",\n                ),\n            name: id.name,\n            returnTyp: returnTyp && (yield* Typ.compile(returnTyp)),\n            typParameters: [],\n          };\n        }),\n      );\n    case \"WhileStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"While loops are not handled\",\n      );\n    // The `with` keyword is forbidden as we are in strict mode.\n    /* istanbul ignore next */\n    case \"WithStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"With statements are not handled\",\n      );\n    /* istanbul ignore next */\n    default:\n      return declaration;\n  }\n}\n\nexport function print(declaration: t): Doc.t {\n  switch (declaration.type) {\n    case \"Definition\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(Doc.concat([\"Definition\", Doc.line, declaration.name])),\n          Doc.indent(\n            Doc.concat([\n              ...(declaration.typParameters.length !== 0\n                ? [Doc.line, Typ.printImplicitTyps(declaration.typParameters)]\n                : []),\n              Expression.printFunArguments(declaration.arguments),\n              Doc.line,\n              Typ.printReturnTyp(declaration.returnTyp, \":=\"),\n              Doc.hardline,\n              Expression.print(false, declaration.body),\n              \".\",\n            ]),\n          ),\n        ]),\n      );\n    case \"TypeDefinition\":\n      return TypDefinition.print(declaration.name, declaration.typDefinition);\n    /* istanbul ignore next */\n    default:\n      return declaration;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Monad from \"./monad.js\";\nimport * as TopLevelStatement from \"./top-level-statement.js\";\n\nexport type t = TopLevelStatement.t[];\n\nexport function* compile(program: BabelAst.Program): Monad.t<t> {\n  const unflattenedStatements = yield* Monad.all(\n    program.body.map(statement => TopLevelStatement.compile(statement)),\n  );\n\n  return unflattenedStatements.reduce(\n    (accumulator: t, statements: TopLevelStatement.t[]) => [\n      ...accumulator,\n      ...statements,\n    ],\n    [],\n  );\n}\n\nexport function print(program: t): Doc.t {\n  return Doc.group(\n    Doc.join(\n      Doc.concat([Doc.hardline, Doc.hardline]),\n      program.map(programElement => TopLevelStatement.print(programElement)),\n    ),\n  );\n}\n","// @flow\n\nexport default `type Rec = {\n  a: string,\n  b: number,\n  c: boolean\n};\n\nconst o = ({a: \"hi\", b: 12, c: false}: Rec);\n\ntype Status =\n  | {\n      type: \"Error\",\n      message: string,\n    }\n  | {\n      type: \"Loading\",\n    }\n  | {\n      type: \"Nothing\",\n    };\n\nconst status: Status = ({type: \"Error\", message: \"hi\"}: Status);\n\nconst\n  b: boolean = false && true,\n  n: number = -12 + 23;\n\nconst s = \"hi\";\n\nconst a = [1, (2 : number), 3];\n\nconst cond = b ? \"a\" : 'b';\n\nfunction id<A, B>(x: A): A {\n  return x;\n}\n\nfunction basicTypes(n: number, m: number): string {\n  return \"OK\";\n}\n\nconst r = id(basicTypes(12, 23));\n\nconst f = function<A> (x : A, y : A): bool {\n  return true;\n}\n\nconst arrow = x => x + 1;\n`;\n","// @flow\nimport React, {PureComponent} from \"react\";\n\ntype Props = {\n  output: string,\n};\n\nexport default class CoqOutput extends PureComponent<Props> {\n  render() {\n    const {output} = this.props;\n\n    return (\n      <code>\n        <pre>{output}</pre>\n      </code>\n    );\n  }\n}\n","// @flow\nimport React, {PureComponent} from \"react\";\nimport codeFrame from \"babel-code-frame\";\nimport {parse} from \"@babel/parser\";\nimport doc from \"prettier/doc.js\";\nimport * as BabelAst from \"./compiler/babel-ast.js\";\nimport * as Error from \"./compiler/error.js\";\nimport * as Monad from \"./compiler/monad.js\";\nimport * as Program from \"./compiler/program.js\";\nimport demoInput from \"./demoInput.js\";\nimport Output from \"./Output.js\";\nimport \"./App.css\";\n\ntype Props = {};\n\ntype State = {\n  jsInput: string,\n};\n\nfunction getInitialJsInput(): string {\n  if (typeof window !== \"undefined\") {\n    const item = window.sessionStorage.getItem(\"jsInput\");\n\n    return typeof item === \"string\" ? item : demoInput;\n  }\n\n  return demoInput;\n}\n\nexport default class App extends PureComponent<Props, State> {\n  state: State = {\n    jsInput: getInitialJsInput(),\n  };\n\n  onChangeJsInput = (event: SyntheticEvent<HTMLTextAreaElement>) => {\n    const {value} = event.currentTarget;\n\n    this.setState({jsInput: value});\n\n    if (typeof window !== \"undefined\") {\n      window.sessionStorage.setItem(\"jsInput\", value);\n    }\n  };\n\n  getJsAst(jsInput: string): BabelAst.File | string {\n    try {\n      const ast = parse(jsInput, {\n        plugins: [\"flow\", \"jsx\"],\n        sourceType: \"module\",\n      });\n\n      return ast;\n    } catch (error) {\n      const {loc} = error;\n\n      return `${error.message}\\n\\n${codeFrame(jsInput, loc.line, loc.column)}`;\n    }\n  }\n\n  getCoqAst(source: string, jsAst: BabelAst.File): Program.t | string {\n    try {\n      const result = Monad.run(Program.compile(jsAst.program));\n\n      switch (result.type) {\n        case \"Error\":\n          return Error.print(source, result.errors);\n        case \"Success\":\n          return result.value;\n        default:\n          return result;\n      }\n    } catch (error) {\n      return error.message;\n    }\n  }\n\n  getCoqString(coqAst: Program.t): string {\n    return doc.printer.printDocToString(Program.print(coqAst), {\n      printWidth: 60,\n      tabWidth: 2,\n    }).formatted;\n  }\n\n  getOutputs(jsInput: string): {coq: string, coqAst: string, jsAst: string} {\n    const jsAst = this.getJsAst(jsInput);\n\n    if (typeof jsAst === \"string\") {\n      return {coq: jsAst, coqAst: \"\", jsAst: \"\"};\n    }\n\n    const coqAst = this.getCoqAst(jsInput, jsAst);\n\n    if (typeof coqAst === \"string\") {\n      return {coq: coqAst, coqAst: \"\", jsAst: \"\"};\n    }\n\n    return {\n      coq: this.getCoqString(coqAst),\n      coqAst: JSON.stringify(coqAst, null, 2),\n      jsAst: JSON.stringify(jsAst, null, 2),\n    };\n  }\n\n  render() {\n    const {jsInput} = this.state;\n    const {coq, coqAst, jsAst} = this.getOutputs(jsInput);\n\n    return (\n      <div>\n        <div className=\"header\">\n          <h1>\n            <span className=\"logo\">\n              <span aria-label=\"globe\" role=\"img\">\n                🌍\n              </span>{\" \"}\n              <span aria-label=\"rooster\" role=\"img\">\n                🐓\n              </span>\n            </span>\n            coq-of-js\n            <a className=\"sub-title\" href=\"https://github.com/clarus/coq-of-js\">\n              Sources\n            </a>\n          </h1>\n        </div>\n        <div className=\"split js-source\">\n          <h2>JavaScript editor</h2>\n          <textarea onChange={this.onChangeJsInput} value={jsInput} />\n        </div>\n        <div className=\"split coq-source\">\n          <h2>Generated Coq</h2>\n          <Output output={coq} />\n        </div>\n        <div className=\"split js-ast\">\n          <h2>JavaScript AST</h2>\n          <Output output={jsAst} />\n        </div>\n        <div className=\"split coq-ast\">\n          <h2>Coq AST</h2>\n          <Output output={coqAst} />\n        </div>\n      </div>\n    );\n  }\n}\n","// @flow\nimport {codeFrameColumns} from \"@babel/code-frame\";\nimport * as BabelAst from \"./babel-ast.js\";\n\nexport type t = {\n  location: ?BabelAst.SourceLocation,\n  message: string,\n};\n\nexport function print(source: string, errors: t[]): string {\n  return errors\n    .map(error => {\n      const errorSourceCode = codeFrameColumns(source, error.location);\n\n      return `${errorSourceCode}\\n\\n${error.message}`;\n    })\n    .join(\"\\n\\n**********************\\n\\n\");\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\",\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\",\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\",\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","// @flow\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst rootElement = document.getElementById(\"root\");\n\nif (rootElement) {\n  ReactDOM.render(<App />, rootElement);\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}