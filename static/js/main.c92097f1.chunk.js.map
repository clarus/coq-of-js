{"version":3,"sources":["compiler/monad.js","compiler/result.js","compiler/doc.js","compiler/identifier.js","compiler/util.js","compiler/typ.js","compiler/expression.js","compiler/typ-definition.js","compiler/top-level-statement.js","compiler/program.js","demoInput.js","Output.js","App.js","compiler/error.js","serviceWorker.js","index.js"],"names":["ret","all","raise","raiseUnhandled","value","expressions","type","reduce","array","accumulator","reducer","a","element","filterMap","f","result","some","predicate","areSome","node","message","JSON","stringify","runWithAnswer","expression","answer","next","done","nextAnswer","results","errors","Result","map","location","loc","doc","builders","concat","group","hardline","indent","join","line","softline","paren","needParens","nameMapping","Props","compile","identifier","name","getObjectKeyName","compileIdentifier","compileIfPlainTyp","key","Identifier","Monad","compileIdentifierOrQualifiedTypeIdentifier","id","qualification","typ","elementType","params","typeAnnotation","returnType","typeParameters","Util","param","returnTyp","typParams","properties","length","types","compiledTyp","printImplicitTyps","names","Doc","print","typParam","getObjectPropertyName","getLeftValueRecordFields","compileLVal","getStringOfStringLiteral","getFieldsDestructuringFromHeadStatement","compileStatements","compileFun","tt","property","Typ","pattern","variable","lval","typName","fields","record","isEmptyDefaultBranch","statements","statement","body","argument","discriminantName","noDestructuring","trailingStatements","headStatement","slice","declarations","declaration","init","discriminant","object","sum","cases","consequent","test","branches","defaultCase","find","branch","defaultBranch","accumulatedNames","currentAccumulatedNames","fun","arguments","typParameters","elements","left","operator","right","callee","alternate","field","computed","constr","instance","printFunArguments","funArguments","printRecordInstance","printLeftValue","withQuote","printMatch","patterns","getObjectTypePropertyName","getStringOfStringLiteralTypeAnnotation","compileStringEnum","compileSumType","typs","nameProperties","fieldProperties","constructors","objectTyp","printModule","printRecord","printDefineTypeAsModule","extractIdentifierOfLVal","Expression","source","TypDefinition","impltype","typDefinition","nextToken","module","constructor","program","TopLevelStatement","unflattenedStatements","CoqOutput","output","this","props","PureComponent","getInitialJsInput","window","item","sessionStorage","getItem","demoInput","App","state","jsInput","onChangeJsInput","event","currentTarget","setState","setItem","parse","plugins","sourceType","error","codeFrame","column","jsAst","Program","errorSourceCode","codeFrameColumns","Error","coqAst","printer","printDocToString","withHeader","programElement","printWidth","tabWidth","formatted","getJsAst","coq","getCoqAst","getCoqString","getOutputs","className","aria-label","role","href","onChange","Boolean","hostname","match","rootElement","document","getElementById","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c92097f1.chunk.js","sourcesContent":["// @flow\n// This monad is used internally by the compiler. It handles the user errors.\n// In contrast to exceptions, it supports one or many errors. Thus the user\n// may get all the errors found by the compiler at once.\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Result from \"./result.js\";\n\ntype Yield =\n  | {\n      type: \"All\",\n      expressions: Generator<Yield, any, any>[],\n    }\n  | {\n      type: \"Raise\",\n      message: string,\n      node: BabelAst.Node,\n    };\n\nexport type t<A> = Generator<Yield, A, any>;\n\n// eslint-disable-next-line require-yield\nexport function* ret<A>(value: A): t<A> {\n  return value;\n}\n\n// Evaluate an array of expressions.\n// Keep all the errors in case there are many.\nexport function* all<A>(expressions: t<A>[]): t<A[]> {\n  return yield {type: \"All\", expressions};\n}\n\nexport function reduce<Accumulator, A>(\n  array: A[],\n  accumulator: Accumulator,\n  reducer: (accumulator: Accumulator, element: A) => t<Accumulator>,\n): t<Accumulator> {\n  return array.reduce(function*(accumulator, element) {\n    return yield* reducer(yield* accumulator, element);\n  }, ret(accumulator));\n}\n\nexport function filterMap<A, B>(array: A[], f: (element: A) => t<?B>): t<B[]> {\n  return reduce(array, [], function*(accumulator: B[], element) {\n    const result = yield* f(element);\n\n    return result ? [...accumulator, result] : accumulator;\n  });\n}\n\nexport function some<A>(\n  array: A[],\n  predicate: (element: A) => t<boolean>,\n): t<boolean> {\n  return reduce(array, false, function*(areSome, element) {\n    return areSome || (yield* predicate(element));\n  });\n}\n\nexport function* raise<A>(node: BabelAst.Node, message: string): t<A> {\n  return yield {type: \"Raise\", message, node};\n}\n\nexport function* raiseUnhandled<A>(node: BabelAst.Node): t<A> {\n  return yield* raise<A>(\n    node,\n    `Unhandled syntax:\\n${JSON.stringify(node, null, 2)}`,\n  );\n}\n\nfunction runWithAnswer<A>(expression: t<A>, answer?: any): Result.t<any> {\n  const result = expression.next(answer);\n\n  if (result.done) {\n    return {\n      type: \"Success\",\n      value: result.value,\n    };\n  }\n\n  const nextAnswer: Result.t<any> = (() => {\n    switch (result.value.type) {\n      case \"All\": {\n        const results = result.value.expressions.map(expression =>\n          runWithAnswer(expression),\n        );\n\n        return Result.merge(results);\n      }\n      case \"Raise\": {\n        const error = {\n          location: result.value.node.loc,\n          message: result.value.message,\n        };\n\n        return {type: \"Error\", errors: [error]};\n      }\n      /* istanbul ignore next */\n      default:\n        return result.value;\n    }\n  })();\n\n  switch (nextAnswer.type) {\n    case \"Error\":\n      return nextAnswer;\n    case \"Success\":\n      return runWithAnswer(expression, nextAnswer.value);\n    /* istanbul ignore next */\n    default:\n      return nextAnswer;\n  }\n}\n\nexport function run<A>(expression: t<A>): Result.t<A> {\n  return runWithAnswer(expression);\n}\n","// @flow\nimport * as Error from \"./error.js\";\n\nexport type t<A> =\n  | {\n      type: \"Error\",\n      errors: Error.t[],\n    }\n  | {\n      type: \"Success\",\n      value: A,\n    };\n\nexport function merge<A>(results: t<A>[]): t<A[]> {\n  return results.reduce(\n    (accumulator: t<A[]>, result: t<A>) => {\n      switch (accumulator.type) {\n        case \"Error\":\n          switch (result.type) {\n            case \"Error\":\n              return {\n                type: \"Error\",\n                errors: [...accumulator.errors, ...result.errors],\n              };\n            case \"Success\":\n              return {\n                type: \"Error\",\n                errors: accumulator.errors,\n              };\n            /* istanbul ignore next */\n            default:\n              return result;\n          }\n        case \"Success\":\n          switch (result.type) {\n            case \"Error\":\n              return {\n                type: \"Error\",\n                errors: result.errors,\n              };\n            case \"Success\":\n              return {\n                type: \"Success\",\n                value: [...accumulator.value, result.value],\n              };\n            /* istanbul ignore next */\n            default:\n              return result;\n          }\n        /* istanbul ignore next */\n        default:\n          return accumulator;\n      }\n    },\n    {type: \"Success\", value: []},\n  );\n}\n","// @flow\n// A wrapper around Prettier doc primitives.\nimport doc from \"prettier/doc.js\";\n\ndeclare opaque type Doc;\n\nexport type t = Doc | string;\n\nconst {\n  concat,\n  group,\n  hardline,\n  indent,\n  join,\n  line,\n  softline,\n}: {\n  concat: (docs: $ReadOnlyArray<t>) => t,\n  group: (doc: t) => t,\n  hardline: t,\n  indent: (doc: t) => t,\n  join: (sep: t, docs: $ReadOnlyArray<t>) => t,\n  line: t,\n  softline: t,\n} = doc.builders;\n\nexport {concat, group, hardline, indent, join, line, softline};\n\nexport function paren(needParens: boolean, doc: t): t {\n  return needParens ? group(concat([\"(\", doc, \")\"])) : doc;\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\n\nconst nameMapping: {[name: string]: string} = {\n  Props: \"_Props\",\n};\n\nexport function compile(identifier: BabelAst.Identifier): string {\n  const {name} = identifier;\n\n  return nameMapping[name] || name;\n}\n","// @flow\n\nexport function filterMap<A, B>(array: A[], f: (element: A) => ?B): B[] {\n  return array.reduce((accumulator: B[], element) => {\n    const result = f(element);\n\n    return result ? [...accumulator, result] : accumulator;\n  }, []);\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Util from \"./util.js\";\n\nexport type t =\n  | {\n      type: \"Function\",\n      params: t[],\n      returnTyp: t,\n      typParams: string[],\n    }\n  | {\n      type: \"Implicit\",\n    }\n  | {\n      type: \"Tuple\",\n      params: t[],\n    }\n  | {\n      type: \"Variable\",\n      name: string,\n      params: t[],\n    };\n\nexport function* getObjectKeyName(key: any): Monad.t<string> {\n  switch (key.type) {\n    case \"Identifier\":\n      return Identifier.compile(key);\n    case \"StringLiteral\":\n      return key.value;\n    default:\n      return yield* Monad.raise<string>(key, \"Computed key name not handled\");\n  }\n}\n\nfunction compileIdentifierOrQualifiedTypeIdentifier(\n  id: BabelAst.Identifier | BabelAst.QualifiedTypeIdentifier,\n): string {\n  switch (id.type) {\n    case \"Identifier\":\n      return Identifier.compile(id);\n    case \"QualifiedTypeIdentifier\":\n      return `${compileIdentifierOrQualifiedTypeIdentifier(\n        id.qualification,\n      )}.${Identifier.compile(id.id)}`;\n    /* istanbul ignore next */\n    default:\n      return id;\n  }\n}\n\nexport function* compileIdentifier(typ: BabelAst.FlowType): Monad.t<string> {\n  switch (typ.type) {\n    case \"GenericTypeAnnotation\":\n      return compileIdentifierOrQualifiedTypeIdentifier(typ.id);\n    default:\n      return yield* Monad.raise<string>(typ, \"Expected a type identifier\");\n  }\n}\n\ntype PlainTypOrRest =\n  | {\n      type: \"PlainTyp\",\n      typ: t,\n    }\n  | {\n      type: \"Rest\",\n      typ:\n        | BabelAst.ObjectTypeAnnotation\n        | BabelAst.StringLiteralTypeAnnotation\n        | BabelAst.UnionTypeAnnotation,\n    };\n\nexport function* compileIfPlainTyp(\n  typ: BabelAst.FlowType,\n): Monad.t<PlainTypOrRest> {\n  switch (typ.type) {\n    case \"AnyTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"The type `any` is not handled\",\n      );\n    case \"ArrayTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"list\",\n          params: [yield* compile(typ.elementType)],\n        },\n      };\n    case \"BooleanLiteralTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"Boolean literals in types are not handled\",\n      );\n    case \"BooleanTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"bool\",\n          params: [],\n        },\n      };\n    case \"EmptyTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"Empty_set\",\n          params: [],\n        },\n      };\n    case \"ExistsTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Implicit\",\n        },\n      };\n    case \"FunctionTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Function\",\n          params: yield* Monad.all(\n            typ.params.map(({typeAnnotation}) => compile(typeAnnotation)),\n          ),\n          returnTyp: yield* compile(typ.returnType),\n          typParams: typ.typeParameters\n            ? Util.filterMap(typ.typeParameters.params, param => param.name)\n            : [],\n        },\n      };\n    case \"GenericTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: compileIdentifierOrQualifiedTypeIdentifier(typ.id),\n          params: [],\n        },\n      };\n    case \"InterfaceTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"Interface types are not handled\",\n      );\n    case \"IntersectionTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"Intersection types are not handled\",\n      );\n    case \"MixedTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"The type `mixed` is not handled\",\n      );\n    case \"NullableTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"option\",\n          params: [yield* compile(typ.typeAnnotation)],\n        },\n      };\n    case \"NullLiteralTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"unit\",\n          params: [],\n        },\n      };\n    case \"NumberLiteralTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"Number literals in types are not handled\",\n      );\n    case \"NumberTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"Z\",\n          params: [],\n        },\n      };\n    case \"ObjectTypeAnnotation\": {\n      if (typ.properties.length === 0) {\n        return {\n          type: \"PlainTyp\",\n          typ: {\n            type: \"Variable\",\n            name: \"unit\",\n            params: [],\n          },\n        };\n      }\n\n      return {\n        type: \"Rest\",\n        typ,\n      };\n    }\n    case \"StringLiteralTypeAnnotation\":\n      return {\n        type: \"Rest\",\n        typ,\n      };\n    case \"StringTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"string\",\n          params: [],\n        },\n      };\n    case \"ThisTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"The type `this` is not handled\",\n      );\n    case \"TupleTypeAnnotation\":\n      if (typ.types.length === 1) {\n        return yield* Monad.raise<PlainTypOrRest>(\n          typ,\n          \"Tuple types with exactly one element are not handled\",\n        );\n      }\n\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Tuple\",\n          params: yield* Monad.all(typ.types.map(typ => compile(typ))),\n        },\n      };\n    case \"TypeofTypeAnnotation\":\n      return yield* Monad.raise<PlainTypOrRest>(\n        typ,\n        \"Extracting the type of values with `typeof` is not handled\",\n      );\n    case \"UnionTypeAnnotation\":\n      return {\n        type: \"Rest\",\n        typ,\n      };\n    case \"VoidTypeAnnotation\":\n      return {\n        type: \"PlainTyp\",\n        typ: {\n          type: \"Variable\",\n          name: \"unit\",\n          params: [],\n        },\n      };\n    /* istanbul ignore next */\n    default:\n      return typ;\n  }\n}\n\nexport function* compile(typ: BabelAst.FlowType): Monad.t<t> {\n  const compiledTyp = yield* compileIfPlainTyp(typ);\n\n  switch (compiledTyp.type) {\n    case \"PlainTyp\":\n      return compiledTyp.typ;\n    case \"Rest\":\n      switch (compiledTyp.typ.type) {\n        case \"ObjectTypeAnnotation\":\n          return yield* Monad.raise<t>(\n            compiledTyp.typ,\n            \"This kind of object type is not handled outside of type definitions\",\n          );\n        case \"StringLiteralTypeAnnotation\":\n          return yield* Monad.raise<t>(\n            compiledTyp.typ,\n            \"String literal types are not handled outside of type definitions\",\n          );\n        case \"UnionTypeAnnotation\":\n          return yield* Monad.raise<t>(\n            compiledTyp.typ,\n            \"Union types are not handled outside of type definitions\",\n          );\n        /* istanbul ignore next */\n        default:\n          return compiledTyp.typ;\n      }\n    /* istanbul ignore next */\n    default:\n      return compiledTyp;\n  }\n}\n\nexport function printImplicitTyps(names: string[]): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"{\",\n      Doc.indent(\n        Doc.concat([\n          Doc.softline,\n          Doc.join(Doc.line, names),\n          Doc.line,\n          Doc.group(Doc.concat([\":\", Doc.line, \"Type\"])),\n        ]),\n      ),\n      Doc.softline,\n      \"}\",\n    ]),\n  );\n}\n\nexport function print(needParens: boolean, typ: t): Doc.t {\n  switch (typ.type) {\n    case \"Function\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            ...(typ.typParams.length !== 0\n              ? [\n                  Doc.group(\n                    Doc.concat([\n                      \"forall\",\n                      Doc.line,\n                      \"{\",\n                      Doc.indent(\n                        Doc.group(\n                          Doc.concat([\n                            Doc.softline,\n                            ...typ.typParams.map(typParam =>\n                              Doc.concat([typParam, Doc.line]),\n                            ),\n                            Doc.group(Doc.concat([\":\", Doc.line, \"Type\"])),\n                          ]),\n                        ),\n                      ),\n                      Doc.softline,\n                      \"}\",\n                      \",\",\n                      Doc.line,\n                    ]),\n                  ),\n                ]\n              : []),\n            ...typ.params.map(param =>\n              Doc.group(\n                Doc.concat([print(true, param), Doc.line, \"->\", Doc.line]),\n              ),\n            ),\n            print(true, typ.returnTyp),\n          ]),\n        ),\n      );\n    case \"Implicit\":\n      return \"_\";\n    case \"Tuple\":\n      switch (typ.params.length) {\n        case 0:\n          return \"unit\";\n        default:\n          return Doc.paren(\n            needParens,\n            Doc.group(\n              Doc.join(\n                Doc.concat([Doc.line, \"*\", Doc.line]),\n                typ.params.map(param => print(true, param)),\n              ),\n            ),\n          );\n      }\n    case \"Variable\":\n      return Doc.paren(\n        needParens && typ.params.length !== 0,\n        Doc.group(\n          Doc.concat([\n            typ.name,\n            Doc.indent(\n              Doc.concat(\n                typ.params.map(param =>\n                  Doc.concat([Doc.line, print(true, param)]),\n                ),\n              ),\n            ),\n          ]),\n        ),\n      );\n    /* istanbul ignore next */\n    default:\n      return typ;\n  }\n}\n\nexport function printReturnTyp(typ: ?t, nextToken: Doc.t): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      ...(typ ? [\":\", Doc.line, print(false, typ), Doc.line] : []),\n      nextToken,\n    ]),\n  );\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as Util from \"./util.js\";\n\ntype LeftValueRecordField = {\n  name: string,\n  variable: string,\n};\n\ntype LeftValue =\n  | {\n      type: \"Record\",\n      fields: LeftValueRecordField[],\n      record: string,\n    }\n  | {\n      type: \"Variable\",\n      name: string,\n    };\n\nexport type t =\n  | {\n      type: \"ArrayExpression\",\n      elements: t[],\n    }\n  | {\n      type: \"BinaryExpression\",\n      left: t,\n      operator: string,\n      right: t,\n    }\n  | {\n      type: \"CallExpression\",\n      arguments: t[],\n      callee: t,\n    }\n  | {\n      type: \"ConditionalExpression\",\n      alternate: t,\n      consequent: t,\n      test: t,\n    }\n  | {\n      type: \"Constant\",\n      value: boolean | number | string,\n    }\n  | {\n      type: \"EnumDestruct\",\n      branches: {body: t, names: string[]}[],\n      defaultBranch: ?t,\n      discriminant: t,\n      typName: string,\n    }\n  | {\n      type: \"EnumInstance\",\n      instance: string,\n      typName: string,\n    }\n  | {\n      type: \"FunctionExpression\",\n      // eslint-disable-next-line no-use-before-define\n      value: Fun,\n    }\n  | {\n      type: \"Let\",\n      body: t,\n      lval: LeftValue,\n      value: t,\n    }\n  | {\n      type: \"RecordInstance\",\n      // eslint-disable-next-line no-use-before-define\n      fields: RecordField[],\n      record: string,\n    }\n  | {\n      type: \"RecordProjection\",\n      field: string,\n      object: t,\n      record: string,\n    }\n  | {\n      type: \"SumDestruct\",\n      branches: {body: t, fields: LeftValueRecordField[], name: string}[],\n      defaultBranch: ?t,\n      discriminant: t,\n      sum: string,\n    }\n  | {\n      type: \"SumInstance\",\n      constr: string,\n      // eslint-disable-next-line no-use-before-define\n      fields: RecordField[],\n      sum: string,\n    }\n  | {\n      type: \"TypeCastExpression\",\n      expression: t,\n      typeAnnotation: Typ.t,\n    }\n  | {\n      type: \"UnaryExpression\",\n      argument: t,\n      operator: string,\n    }\n  | {\n      type: \"Variable\",\n      name: string,\n    };\n\nexport type FunArgument = {\n  name: string,\n  typ: ?Typ.t,\n};\n\nexport type Fun = {\n  arguments: FunArgument[],\n  body: t,\n  returnTyp: ?Typ.t,\n  typParameters: string[],\n};\n\ntype RecordField = {\n  name: string,\n  value: t,\n};\n\nexport const tt: t = {\n  type: \"Variable\",\n  name: \"tt\",\n};\n\nfunction* getObjectPropertyName(\n  property: BabelAst.ObjectProperty,\n): Monad.t<string> {\n  return yield* Typ.getObjectKeyName(property.key);\n}\n\nfunction* getLeftValueRecordFields(\n  pattern: BabelAst.ObjectPattern,\n): Monad.t<LeftValueRecordField[]> {\n  return yield* Monad.all(\n    pattern.properties.map(function*(property) {\n      switch (property.type) {\n        case \"ObjectProperty\":\n          switch (property.value.type) {\n            case \"Identifier\": {\n              const {value} = property;\n\n              return {\n                name: yield* getObjectPropertyName(property),\n                variable: Identifier.compile(value),\n              };\n            }\n            default:\n              return yield* Monad.raise<LeftValueRecordField>(\n                property.value,\n                \"Expected an identifier\",\n              );\n          }\n        case \"RestElement\":\n          return yield* Monad.raise<LeftValueRecordField>(\n            property,\n            \"Unhandled rest element for record destructuring\",\n          );\n        /* istanbul ignore next */\n        default:\n          return property;\n      }\n    }),\n  );\n}\n\nfunction* compileLVal(lval: BabelAst.LVal): Monad.t<LeftValue> {\n  switch (lval.type) {\n    case \"ArrayPattern\":\n      return yield* Monad.raise<LeftValue>(lval, \"Unhandled array patterns\");\n    /* istanbul ignore next */\n    case \"AssignmentPattern\":\n      return yield* Monad.raise<LeftValue>(\n        lval,\n        \"Unexpected assignment patterns\",\n      );\n    case \"Identifier\":\n      return {\n        type: \"Variable\",\n        name: Identifier.compile(lval),\n      };\n    /* istanbul ignore next */\n    case \"MemberExpression\":\n      return yield* Monad.raise<LeftValue>(lval, \"Unexpected member access\");\n    case \"ObjectPattern\": {\n      const typName = lval.typeAnnotation\n        ? yield* Typ.compileIdentifier(lval.typeAnnotation.typeAnnotation)\n        : yield* Monad.raise<string>(\n            lval,\n            \"Expected a type annotation for record destructuring\",\n          );\n      const fields = yield* getLeftValueRecordFields(lval);\n\n      return {\n        type: \"Record\",\n        fields,\n        record: typName,\n      };\n    }\n    /* istanbul ignore next */\n    case \"RestElement\":\n      return yield* Monad.raise<LeftValue>(lval, \"Unexpected rest elements\");\n    /* istanbul ignore next */\n    default:\n      return lval;\n  }\n}\n\nfunction* getStringOfStringLiteral(\n  expression: BabelAst.Expression,\n): Monad.t<string> {\n  switch (expression.type) {\n    case \"StringLiteral\":\n      return expression.value;\n    default:\n      return yield* Monad.raise<string>(\n        expression,\n        \"Expected a string literal\",\n      );\n  }\n}\n\nfunction isEmptyDefaultBranch(statements: BabelAst.Statement[]): boolean {\n  if (statements.length >= 1) {\n    const statement = statements[0];\n    switch (statement.type) {\n      case \"BlockStatement\":\n        return isEmptyDefaultBranch(statement.body);\n      case \"ReturnStatement\":\n        if (statement.argument) {\n          switch (statement.argument.type) {\n            case \"TypeCastExpression\":\n              switch (statement.argument.typeAnnotation.typeAnnotation.type) {\n                case \"EmptyTypeAnnotation\":\n                  return true;\n                default:\n                  return false;\n              }\n            default:\n              return false;\n          }\n        }\n        return false;\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}\n\ntype FieldsDestructuringFromHeadStatement = {\n  fields: LeftValueRecordField[],\n  trailingStatements: BabelAst.Statement[],\n};\n\nfunction* getFieldsDestructuringFromHeadStatement(\n  statements: BabelAst.Statement[],\n  discriminantName: string,\n): Monad.t<FieldsDestructuringFromHeadStatement> {\n  const noDestructuring = {fields: [], trailingStatements: statements};\n\n  if (statements.length === 0) {\n    return noDestructuring;\n  }\n\n  const headStatement = statements[0];\n\n  switch (headStatement.type) {\n    case \"BlockStatement\":\n      return yield* getFieldsDestructuringFromHeadStatement(\n        [...headStatement.body, ...statements.slice(1)],\n        discriminantName,\n      );\n    case \"VariableDeclaration\": {\n      if (headStatement.declarations.length !== 1) {\n        return yield* Monad.raise<FieldsDestructuringFromHeadStatement>(\n          headStatement,\n          \"Expected a single definition of variable\",\n        );\n      }\n\n      const declaration = headStatement.declarations[0];\n\n      if (declaration.init) {\n        switch (declaration.init.type) {\n          case \"Identifier\": {\n            const {name} = declaration.init;\n\n            if (name === discriminantName) {\n              switch (declaration.id.type) {\n                case \"ObjectPattern\": {\n                  const fields = yield* getLeftValueRecordFields(\n                    declaration.id,\n                  );\n\n                  return {\n                    fields,\n                    trailingStatements: statements.slice(1),\n                  };\n                }\n                default:\n                  return yield* Monad.raise<FieldsDestructuringFromHeadStatement>(\n                    declaration.id,\n                    \"Expected an object pattern to destructure a sum type\",\n                  );\n              }\n            }\n\n            return noDestructuring;\n          }\n          default:\n            return noDestructuring;\n        }\n      }\n\n      return noDestructuring;\n    }\n    default:\n      return noDestructuring;\n  }\n}\n\nexport function* compileStatements(\n  statements: BabelAst.Statement[],\n): Monad.t<t> {\n  if (statements.length === 0) {\n    return tt;\n  }\n\n  const statement = statements[0];\n\n  switch (statement.type) {\n    case \"BlockStatement\":\n      return yield* compileStatements([\n        ...statement.body,\n        ...statements.slice(1),\n      ]);\n    case \"ReturnStatement\":\n      return statement.argument ? yield* compile(statement.argument) : tt;\n    case \"SwitchStatement\":\n      switch (statement.discriminant.type) {\n        // Destructuring of sum type.\n        case \"MemberExpression\": {\n          const {discriminant} = statement;\n          const field = yield* Typ.getObjectKeyName(discriminant.property);\n\n          if (field !== \"type\") {\n            return yield* Monad.raise<t>(\n              discriminant.property,\n              \"Expected an access on the `type` field to destructure a sum type\",\n            );\n          }\n\n          switch (discriminant.object.type) {\n            case \"TypeCastExpression\": {\n              const {expression, typeAnnotation} = discriminant.object;\n              const sum = yield* Typ.compileIdentifier(\n                typeAnnotation.typeAnnotation,\n              );\n\n              switch (expression.type) {\n                case \"Identifier\": {\n                  const discriminantName = expression.name;\n                  const branches = yield* Monad.filterMap(\n                    statement.cases,\n                    function*({consequent, test}) {\n                      if (!test) {\n                        return null;\n                      }\n\n                      const {\n                        fields,\n                        trailingStatements,\n                      } = yield* getFieldsDestructuringFromHeadStatement(\n                        consequent,\n                        discriminantName,\n                      );\n\n                      return {\n                        body: yield* compileStatements(trailingStatements),\n                        fields,\n                        name: yield* getStringOfStringLiteral(test),\n                      };\n                    },\n                  );\n                  const defaultCase =\n                    statement.cases.find(\n                      branch =>\n                        !branch.test &&\n                        !isEmptyDefaultBranch(branch.consequent),\n                    ) || null;\n\n                  return {\n                    type: \"SumDestruct\",\n                    branches,\n                    defaultBranch:\n                      defaultCase &&\n                      (yield* compileStatements(defaultCase.consequent)),\n                    discriminant: yield* compile(expression),\n                    sum,\n                  };\n                }\n                default:\n                  return yield* Monad.raise<t>(\n                    expression,\n                    \"Expected a switch on an identifier to destructure a sum type\",\n                  );\n              }\n            }\n            default:\n              return yield* Monad.raise<t>(\n                discriminant.object,\n                \"Expected a type annotation on this expression to destructure a sum type\",\n              );\n          }\n        }\n        // Destructuring of enum.\n        case \"TypeCastExpression\": {\n          const {expression, typeAnnotation} = statement.discriminant;\n          const {accumulatedNames, branches} = yield* Monad.reduce<\n            {\n              accumulatedNames: string[],\n              branches: {body: t, names: string[]}[],\n            },\n            BabelAst.SwitchCase,\n          >(statement.cases, {accumulatedNames: [], branches: []}, function*(\n            {accumulatedNames, branches},\n            branch,\n          ) {\n            if (!branch.test) {\n              return {accumulatedNames: [], branches};\n            }\n\n            const name = yield* getStringOfStringLiteral(branch.test);\n            const currentAccumulatedNames = [...accumulatedNames, name];\n\n            if (branch.consequent.length === 0) {\n              return {accumulatedNames: currentAccumulatedNames, branches};\n            }\n\n            return {\n              accumulatedNames: [],\n              branches: [\n                ...branches,\n                {\n                  body: yield* compileStatements(branch.consequent),\n                  names: currentAccumulatedNames,\n                },\n              ],\n            };\n          });\n          const defaultCase =\n            statement.cases.find(\n              branch =>\n                !branch.test && !isEmptyDefaultBranch(branch.consequent),\n            ) || null;\n\n          return {\n            type: \"EnumDestruct\",\n            branches: [\n              ...branches,\n              ...(accumulatedNames.length !== 0\n                ? [{body: tt, names: accumulatedNames}]\n                : []),\n            ],\n            defaultBranch:\n              defaultCase && (yield* compileStatements(defaultCase.consequent)),\n            discriminant: yield* compile(expression),\n            typName: yield* Typ.compileIdentifier(\n              typeAnnotation.typeAnnotation,\n            ),\n          };\n        }\n        default:\n          return yield* Monad.raise<t>(\n            statement.discriminant,\n            \"Missing type annotation to destructure an enum\",\n          );\n      }\n    case \"VariableDeclaration\": {\n      if (statement.declarations.length !== 1) {\n        return yield* Monad.raise<t>(\n          statement,\n          \"Expected exactly one definition\",\n        );\n      }\n\n      const declaration = statement.declarations[0];\n\n      return {\n        type: \"Let\",\n        body: yield* compileStatements(statements.slice(1)),\n        lval: yield* compileLVal(declaration.id),\n        value: declaration.init\n          ? yield* compile(declaration.init)\n          : yield* Monad.raise<t>(\n              declaration,\n              \"Expected a definition with a value\",\n            ),\n      };\n    }\n    default:\n      return yield* Monad.raiseUnhandled<t>(statement);\n  }\n}\n\nexport function* compileFun(\n  fun:\n    | BabelAst.FunctionDeclaration\n    | BabelAst.FunctionExpression\n    | BabelAst.ArrowFunctionExpression,\n): Monad.t<Fun> {\n  const returnTyp = fun.returnType ? fun.returnType.typeAnnotation : null;\n\n  return {\n    arguments: yield* Monad.all(\n      fun.params.map(function*(param) {\n        switch (param.type) {\n          case \"Identifier\":\n            return {\n              name: param.name,\n              typ: param.typeAnnotation\n                ? yield* Typ.compile(param.typeAnnotation.typeAnnotation)\n                : null,\n            };\n          default:\n            return yield* Monad.raise<FunArgument>(\n              param,\n              \"Expected simple identifier as function parameter\",\n            );\n        }\n      }),\n    ),\n    body:\n      fun.body.type === \"BlockStatement\"\n        ? yield* compileStatements(fun.body.body)\n        : yield* compile(fun.body),\n    returnTyp: returnTyp && (yield* Typ.compile(returnTyp)),\n    typParameters: fun.typeParameters\n      ? Util.filterMap(fun.typeParameters.params, param => param.name)\n      : [],\n  };\n}\n\nexport function* compile(expression: BabelAst.Expression): Monad.t<t> {\n  switch (expression.type) {\n    case \"ArrayExpression\":\n      return {\n        type: \"ArrayExpression\",\n        elements: expression.elements\n          ? yield* Monad.all(\n              expression.elements.map(function*(element) {\n                if (!element) {\n                  return yield* Monad.raise<t>(\n                    expression,\n                    \"Expected non-empty elements in the array\",\n                  );\n                }\n\n                if (element.type === \"SpreadElement\") {\n                  return yield* Monad.raise<t>(\n                    element,\n                    \"Spreads in arrays are not handled\",\n                  );\n                }\n\n                return yield* compile(element);\n              }),\n            )\n          : /* istanbul ignore next */\n            yield* Monad.raise<t[]>(\n              expression,\n              \"Unexpected empty array expression\",\n            ),\n      };\n    case \"ArrowFunctionExpression\":\n      return {\n        type: \"FunctionExpression\",\n        value: yield* compileFun(expression),\n      };\n    case \"BinaryExpression\":\n      return {\n        type: \"BinaryExpression\",\n        left: yield* compile(expression.left),\n        operator: expression.operator,\n        right: yield* compile(expression.right),\n      };\n    case \"BooleanLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"CallExpression\":\n      return {\n        type: \"CallExpression\",\n        arguments: yield* Monad.all(\n          expression.arguments.map(function*(argument) {\n            switch (argument.type) {\n              case \"ArgumentPlaceholder\":\n                return yield* Monad.raise<t>(\n                  argument,\n                  \"Unhandled partial application\",\n                );\n              case \"SpreadElement\":\n                return yield* Monad.raise<t>(\n                  argument,\n                  \"Unhandled spread parameters\",\n                );\n              default:\n                return yield* compile(argument);\n            }\n          }),\n        ),\n        callee: yield* compile(expression.callee),\n      };\n    case \"ConditionalExpression\":\n      return {\n        type: \"ConditionalExpression\",\n        alternate: yield* compile(expression.alternate),\n        consequent: yield* compile(expression.consequent),\n        test: yield* compile(expression.test),\n      };\n    case \"FunctionExpression\":\n      return {\n        type: \"FunctionExpression\",\n        value: yield* compileFun(expression),\n      };\n    case \"Identifier\":\n      return {\n        type: \"Variable\",\n        name: expression.name,\n      };\n    case \"LogicalExpression\":\n      return {\n        type: \"BinaryExpression\",\n        left: yield* compile(expression.left),\n        operator: expression.operator,\n        right: yield* compile(expression.right),\n      };\n    case \"MemberExpression\": {\n      switch (expression.object.type) {\n        case \"TypeCastExpression\": {\n          const {expression: object, typeAnnotation} = expression.object;\n          const record = yield* Typ.compileIdentifier(\n            typeAnnotation.typeAnnotation,\n          );\n          const field = yield* Typ.getObjectKeyName(expression.property);\n\n          return {\n            type: \"RecordProjection\",\n            field,\n            object: yield* compile(object),\n            record,\n          };\n        }\n        default:\n          return yield* Monad.raise<t>(\n            expression.object,\n            \"Expected a type annotation on this object to access a member\",\n          );\n      }\n    }\n    case \"NullLiteral\":\n      return tt;\n    case \"NumericLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"ObjectExpression\": {\n      if (expression.properties.length === 0) {\n        return tt;\n      }\n\n      return yield* Monad.raise<t>(\n        expression,\n        \"Unhandled object expression without type annotation\",\n      );\n    }\n    /* istanbul ignore next */\n    case \"ParenthesizedExpression\":\n      return yield* compile(expression.expression);\n    case \"StringLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"TypeCastExpression\": {\n      switch (expression.expression.type) {\n        case \"ObjectExpression\": {\n          const [names, fields] = yield* Monad.reduce(\n            expression.expression.properties,\n            [[], []],\n            function*([names, fields], property) {\n              if (property.type !== \"ObjectProperty\") {\n                return yield* Monad.raise<[*, *]>(\n                  property,\n                  \"Expected a named property\",\n                );\n              }\n\n              if (property.computed) {\n                return yield* Monad.raise<[*, *]>(\n                  property.key,\n                  \"Unhandled computed property name\",\n                );\n              }\n\n              const name = yield* getObjectPropertyName(property);\n              // Because this seems to be the case here and for\n              // performance reasons for the type checking.\n              const value: BabelAst.Expression = (property.value: any);\n\n              if (name === \"type\") {\n                return [\n                  [...names, yield* getStringOfStringLiteral(value)],\n                  fields,\n                ];\n              }\n\n              return [names, [...fields, {name, value: yield* compile(value)}]];\n            },\n          );\n          const typName = yield* Typ.compileIdentifier(\n            expression.typeAnnotation.typeAnnotation,\n          );\n\n          return names.length === 0\n            ? {type: \"RecordInstance\", record: typName, fields}\n            : {\n                type: \"SumInstance\",\n                constr: names[0],\n                fields,\n                sum: typName,\n              };\n        }\n        case \"StringLiteral\": {\n          const {value} = expression.expression;\n\n          return {\n            type: \"EnumInstance\",\n            instance: value,\n            typName: yield* Typ.compileIdentifier(\n              expression.typeAnnotation.typeAnnotation,\n            ),\n          };\n        }\n        default:\n          return {\n            type: \"TypeCastExpression\",\n            expression: yield* compile(expression.expression),\n            typeAnnotation: yield* Typ.compile(\n              expression.typeAnnotation.typeAnnotation,\n            ),\n          };\n      }\n    }\n    case \"UnaryExpression\":\n      return {\n        type: \"UnaryExpression\",\n        argument: yield* compile(expression.argument),\n        operator: expression.operator,\n      };\n    default:\n      return yield* Monad.raiseUnhandled<t>(expression);\n  }\n}\n\nexport function printFunArguments(funArguments: FunArgument[]): Doc.t {\n  return Doc.concat(\n    funArguments.map(({name, typ}) =>\n      Doc.concat([\n        Doc.line,\n        typ\n          ? Doc.group(\n              Doc.concat([\n                \"(\",\n                name,\n                Doc.line,\n                \":\",\n                Doc.line,\n                Typ.print(false, typ),\n                \")\",\n              ]),\n            )\n          : name,\n      ]),\n    ),\n  );\n}\n\nfunction printRecordInstance(\n  record: string,\n  fields: {name: string, value: Doc.t}[],\n): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"{|\",\n      Doc.indent(\n        Doc.concat(\n          fields.map(({name, value}) =>\n            Doc.concat([\n              Doc.line,\n              Doc.group(\n                Doc.concat([\n                  Doc.group(Doc.concat([`${record}.${name}`, Doc.line, \":=\"])),\n                  Doc.indent(Doc.concat([Doc.line, value, \";\"])),\n                ]),\n              ),\n            ]),\n          ),\n        ),\n      ),\n      Doc.line,\n      \"|}\",\n    ]),\n  );\n}\n\nfunction printLeftValue(lval: LeftValue, withQuote: boolean): Doc.t {\n  switch (lval.type) {\n    case \"Record\":\n      if (lval.fields.length === 0) {\n        return \"_\";\n      }\n\n      return Doc.concat([\n        ...(withQuote ? [\"'\"] : []),\n        printRecordInstance(\n          lval.record,\n          lval.fields.map(({name, variable}) => ({name, value: variable})),\n        ),\n      ]);\n    case \"Variable\":\n      return lval.name;\n    /* istanbul ignore next */\n    default:\n      return lval;\n  }\n}\n\nfunction printMatch(\n  discriminant: Doc.t,\n  branches: {\n    body: Doc.t,\n    patterns: {\n      fields: ?(LeftValueRecordField[]),\n      name: string,\n    }[],\n  }[],\n  defaultBranch: ?Doc.t,\n  typName: string,\n): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      Doc.group(\n        Doc.concat([\"match\", Doc.line, discriminant, Doc.line, \"with\"]),\n      ),\n      Doc.hardline,\n      ...branches.map(({body, patterns}) =>\n        Doc.group(\n          Doc.concat([\n            Doc.join(\n              Doc.line,\n              patterns.map(({fields, name}) =>\n                Doc.group(\n                  Doc.concat([\n                    \"|\",\n                    Doc.line,\n                    `${typName}.${name}`,\n                    ...(fields\n                      ? [\n                          Doc.line,\n                          printLeftValue(\n                            {\n                              type: \"Record\",\n                              fields,\n                              record: `${typName}.${name}`,\n                            },\n                            false,\n                          ),\n                        ]\n                      : []),\n                  ]),\n                ),\n              ),\n            ),\n            Doc.line,\n            \"=>\",\n            Doc.indent(Doc.concat([Doc.line, body])),\n            Doc.hardline,\n          ]),\n        ),\n      ),\n      ...(defaultBranch\n        ? [\n            Doc.group(\n              Doc.concat([\n                Doc.group(Doc.concat([\"|\", Doc.line, \"_\", Doc.line, \"=>\"])),\n                Doc.indent(Doc.concat([Doc.line, defaultBranch])),\n                Doc.hardline,\n              ]),\n            ),\n          ]\n        : []),\n      \"end\",\n    ]),\n  );\n}\n\nexport function print(needParens: boolean, expression: t): Doc.t {\n  switch (expression.type) {\n    case \"ArrayExpression\":\n      if (expression.elements.length === 0) {\n        return \"[]\";\n      }\n\n      return Doc.group(\n        Doc.concat([\n          \"[\",\n          Doc.indent(\n            Doc.concat([\n              Doc.line,\n              Doc.join(\n                Doc.concat([\";\", Doc.line]),\n                expression.elements.map(element => print(false, element)),\n              ),\n            ]),\n          ),\n          Doc.line,\n          \"]\",\n        ]),\n      );\n    case \"BinaryExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.join(Doc.line, [\n            print(true, expression.left),\n            expression.operator,\n            print(true, expression.right),\n          ]),\n        ),\n      );\n    case \"CallExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.indent(\n            Doc.join(Doc.line, [\n              print(true, expression.callee),\n              ...expression.arguments.map(argument => print(true, argument)),\n            ]),\n          ),\n        ),\n      );\n    case \"ConditionalExpression\": {\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            Doc.group(\n              Doc.concat([\n                \"if\",\n                Doc.line,\n                print(false, expression.test),\n                Doc.line,\n                \"then\",\n              ]),\n            ),\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.consequent)]),\n            ),\n            Doc.line,\n            \"else\",\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.alternate)]),\n            ),\n          ]),\n        ),\n      );\n    }\n    case \"Constant\":\n      return JSON.stringify(expression.value);\n    case \"EnumDestruct\": {\n      const {branches, defaultBranch, discriminant, typName} = expression;\n\n      return printMatch(\n        print(false, discriminant),\n        branches.map(({body, names}) => ({\n          body: print(false, body),\n          patterns: names.map(name => ({fields: null, name})),\n        })),\n        defaultBranch && print(false, defaultBranch),\n        typName,\n      );\n    }\n    case \"EnumInstance\":\n      return `${expression.typName}.${expression.instance}`;\n    case \"FunctionExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            Doc.group(\n              Doc.concat([\n                \"fun\",\n                Doc.indent(\n                  Doc.concat([\n                    ...(expression.value.typParameters.length !== 0\n                      ? [\n                          Doc.line,\n                          Typ.printImplicitTyps(expression.value.typParameters),\n                        ]\n                      : []),\n                    printFunArguments(expression.value.arguments),\n                  ]),\n                ),\n                Doc.line,\n                \"=>\",\n              ]),\n            ),\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.value.body)]),\n            ),\n          ]),\n        ),\n      );\n    case \"Let\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(\n            Doc.concat([\n              \"let\",\n              Doc.line,\n              printLeftValue(expression.lval, true),\n              Doc.line,\n              \":=\",\n            ]),\n          ),\n          Doc.indent(Doc.concat([Doc.line, print(false, expression.value)])),\n          Doc.line,\n          \"in\",\n          Doc.hardline,\n          print(false, expression.body),\n        ]),\n      );\n    case \"RecordInstance\":\n      return printRecordInstance(\n        expression.record,\n        expression.fields.map(({name, value}) => ({\n          name,\n          value: print(false, value),\n        })),\n      );\n    case \"RecordProjection\":\n      return Doc.group(\n        Doc.concat([\n          print(true, expression.object),\n          Doc.softline,\n          \".(\",\n          Doc.indent(\n            Doc.group(\n              Doc.concat([\n                Doc.softline,\n                expression.record,\n                \".\",\n                expression.field,\n              ]),\n            ),\n          ),\n          Doc.softline,\n          \")\",\n        ]),\n      );\n    case \"SumDestruct\": {\n      const {branches, defaultBranch, discriminant, sum} = expression;\n\n      return printMatch(\n        print(false, discriminant),\n        branches.map(({body, fields, name}) => ({\n          body: print(false, body),\n          patterns: [{fields, name}],\n        })),\n        defaultBranch && print(false, defaultBranch),\n        sum,\n      );\n    }\n    case \"SumInstance\": {\n      const name = `${expression.sum}.${expression.constr}`;\n\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            name,\n            Doc.line,\n            ...(expression.fields.length !== 0\n              ? [\n                  printRecordInstance(\n                    name,\n                    expression.fields.map(({name, value}) => ({\n                      name,\n                      value: print(false, value),\n                    })),\n                  ),\n                ]\n              : [\"tt\"]),\n          ]),\n        ),\n      );\n    }\n    case \"TypeCastExpression\":\n      return Doc.group(\n        Doc.concat([\n          \"(\",\n          Doc.softline,\n          print(true, expression.expression),\n          Doc.line,\n          \":\",\n          Doc.line,\n          Typ.print(false, expression.typeAnnotation),\n          Doc.softline,\n          \")\",\n        ]),\n      );\n    case \"UnaryExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            expression.operator,\n            Doc.line,\n            print(true, expression.argument),\n          ]),\n        ),\n      );\n    case \"Variable\":\n      return expression.name;\n    /* istanbul ignore next */\n    default:\n      return expression;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as Util from \"./util.js\";\n\ntype Constructor = {name: string, fields: {name: string, typ: Typ.t}[]};\n\nexport type t =\n  | {\n      type: \"Enum\",\n      names: string[],\n    }\n  | {\n      type: \"Record\",\n      fields: {name: string, typ: Typ.t}[],\n    }\n  | {\n      type: \"Sum\",\n      constructors: Constructor[],\n    }\n  | {\n      type: \"Synonym\",\n      typ: Typ.t,\n    };\n\nfunction* getObjectTypePropertyName(\n  property: BabelAst.ObjectTypeProperty,\n): Monad.t<string> {\n  return yield* Typ.getObjectKeyName(property.key);\n}\n\nfunction* getStringOfStringLiteralTypeAnnotation(\n  typ: BabelAst.FlowType,\n): Monad.t<string> {\n  switch (typ.type) {\n    case \"StringLiteralTypeAnnotation\":\n      return typ.value;\n    default:\n      return yield* Monad.raise<string>(typ, \"Expected a string literal\");\n  }\n}\n\nfunction* compileStringEnum(typs: BabelAst.FlowType[]): Monad.t<t> {\n  const names = yield* Monad.all(\n    typs.map(function*(typ) {\n      switch (typ.type) {\n        case \"StringLiteralTypeAnnotation\":\n          return typ.value;\n        default:\n          return yield* Monad.raise<string>(\n            typ,\n            \"Only strings are handled in enums\",\n          );\n      }\n    }),\n  );\n\n  return {\n    type: \"Enum\",\n    names,\n  };\n}\n\nfunction* compileSumType(typs: BabelAst.FlowType[]): Monad.t<t> {\n  const constructors = yield* Monad.all(\n    typs.map(function*(typ) {\n      switch (typ.type) {\n        case \"ObjectTypeAnnotation\": {\n          const [nameProperties, fieldProperties] = yield* Monad.reduce(\n            typ.properties,\n            [[], []],\n            function*([nameProperties, fieldProperties], property) {\n              if (property.type !== \"ObjectTypeProperty\") {\n                return yield* Monad.raise<[*, *]>(\n                  property,\n                  \"Expected a named property\",\n                );\n              }\n\n              const name = yield* getObjectTypePropertyName(property);\n\n              return name === \"type\"\n                ? [[...nameProperties, property], fieldProperties]\n                : [nameProperties, [...fieldProperties, property]];\n            },\n          );\n\n          if (nameProperties.length === 0) {\n            return yield* Monad.raise<Constructor>(\n              typ,\n              \"Expected at least one field with the name `type`\",\n            );\n          }\n\n          return {\n            name: yield* getStringOfStringLiteralTypeAnnotation(\n              nameProperties[0].value,\n            ),\n            fields: yield* Monad.all(\n              fieldProperties.map(function*(\n                property: BabelAst.ObjectTypeProperty,\n              ) {\n                return {\n                  name: yield* getObjectTypePropertyName(property),\n                  typ: yield* Typ.compile(property.value),\n                };\n              }),\n            ),\n          };\n        }\n        default:\n          return yield* Monad.raise<Constructor>(\n            typ,\n            \"Only objects are handled in sum types\",\n          );\n      }\n    }),\n  );\n\n  return {\n    type: \"Sum\",\n    constructors,\n  };\n}\n\nexport function* compile(typ: BabelAst.FlowType): Monad.t<t> {\n  const compiledTyp = yield* Typ.compileIfPlainTyp(typ);\n\n  switch (compiledTyp.type) {\n    case \"PlainTyp\":\n      return {\n        type: \"Synonym\",\n        typ: compiledTyp.typ,\n      };\n    case \"Rest\":\n      switch (compiledTyp.typ.type) {\n        case \"ObjectTypeAnnotation\": {\n          const objectTyp = compiledTyp.typ;\n          const withATypeField = yield* Monad.some(\n            objectTyp.properties,\n            function*(property) {\n              switch (property.type) {\n                case \"ObjectTypeProperty\":\n                  return (\n                    (yield* getObjectTypePropertyName(property)) === \"type\"\n                  );\n                default:\n                  return false;\n              }\n            },\n          );\n\n          if (withATypeField) {\n            return yield* compileSumType([objectTyp]);\n          }\n\n          const fields = yield* Monad.all(\n            objectTyp.properties.map(function*(property) {\n              if (property.type !== \"ObjectTypeProperty\") {\n                return yield* Monad.raise(property, \"Expected named property\");\n              }\n\n              return {\n                name: yield* getObjectTypePropertyName(property),\n                typ: yield* Typ.compile(property.value),\n              };\n            }),\n          );\n\n          return {\n            type: \"Record\",\n            fields,\n          };\n        }\n        case \"StringLiteralTypeAnnotation\":\n          return yield* compileStringEnum([compiledTyp.typ]);\n        case \"UnionTypeAnnotation\": {\n          /* istanbul ignore next */\n          if (compiledTyp.typ.types.length === 0) {\n            return {\n              type: \"Synonym\",\n              typ: {\n                type: \"Variable\",\n                name: \"Empty_set\",\n                params: [],\n              },\n            };\n          }\n\n          switch (compiledTyp.typ.types[0].type) {\n            case \"ObjectTypeAnnotation\":\n              return yield* compileSumType(compiledTyp.typ.types);\n            case \"StringLiteralTypeAnnotation\":\n              return yield* compileStringEnum(compiledTyp.typ.types);\n            default:\n              return yield* Monad.raise<t>(\n                compiledTyp.typ,\n                \"Only handle unions of strings or objects with a `type` field\",\n              );\n          }\n        }\n        /* istanbul ignore next */\n        default:\n          return compiledTyp.typ;\n      }\n    /* istanbul ignore next */\n    default:\n      return compiledTyp;\n  }\n}\n\nfunction printModule(name: string, doc: Doc.t): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      Doc.group(Doc.concat([\"Module\", Doc.line, name, \".\"])),\n      Doc.indent(Doc.concat([Doc.hardline, doc])),\n      Doc.group(Doc.concat([Doc.hardline, \"End\", Doc.line, name, \".\"])),\n    ]),\n  );\n}\n\nfunction printRecord(\n  name: string,\n  fields: {name: string, typ: Typ.t}[],\n): Doc.t {\n  return Doc.concat([\n    Doc.group(\n      Doc.concat([\"Record\", Doc.line, \"t\", Doc.line, \":=\", Doc.line, \"{\"]),\n    ),\n    Doc.indent(\n      Doc.concat(\n        fields.map(({name, typ}) =>\n          Doc.concat([\n            Doc.hardline,\n            name,\n            Doc.line,\n            \":\",\n            Doc.line,\n            Typ.print(false, typ),\n            Doc.softline,\n            \";\",\n          ]),\n        ),\n      ),\n    ),\n    Doc.hardline,\n    \"}.\",\n  ]);\n}\n\nfunction printDefineTypeAsModule(name: string): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"Definition\",\n      Doc.line,\n      name,\n      Doc.line,\n      \":=\",\n      Doc.line,\n      `${name}.t`,\n      \".\",\n    ]),\n  );\n}\n\nexport function print(name: string, typDefinition: t): Doc.t {\n  switch (typDefinition.type) {\n    case \"Enum\": {\n      const module = printModule(\n        name,\n        Doc.concat([\n          Doc.group(Doc.concat([\"Inductive\", Doc.line, \"t\", Doc.line, \":=\"])),\n          ...typDefinition.names.map(name =>\n            Doc.group(Doc.concat([Doc.hardline, \"|\", Doc.line, name])),\n          ),\n          \".\",\n        ]),\n      );\n\n      return Doc.concat([module, Doc.hardline, printDefineTypeAsModule(name)]);\n    }\n    case \"Record\":\n      return Doc.concat([\n        printModule(name, printRecord(\"t\", typDefinition.fields)),\n        Doc.hardline,\n        printDefineTypeAsModule(name),\n      ]);\n    case \"Sum\": {\n      const module = printModule(\n        name,\n        Doc.concat([\n          Doc.join(Doc.concat([Doc.hardline, Doc.hardline]), [\n            ...Util.filterMap(typDefinition.constructors, constructor =>\n              constructor.fields.length !== 0\n                ? printModule(\n                    constructor.name,\n                    printRecord(\"t\", constructor.fields),\n                  )\n                : null,\n            ),\n            Doc.group(\n              Doc.concat([\n                Doc.group(\n                  Doc.concat([\"Inductive\", Doc.line, \"t\", Doc.line, \":=\"]),\n                ),\n                ...typDefinition.constructors.map(({name, fields}) =>\n                  Doc.group(\n                    Doc.concat([\n                      Doc.hardline,\n                      \"|\",\n                      Doc.line,\n                      name,\n                      Doc.line,\n                      \"(\",\n                      Doc.softline,\n                      \"_\",\n                      Doc.line,\n                      \":\",\n                      Doc.line,\n                      ...(fields.length !== 0 ? [name, \".t\"] : [\"unit\"]),\n                      Doc.softline,\n                      \")\",\n                    ]),\n                  ),\n                ),\n                \".\",\n              ]),\n            ),\n          ]),\n        ]),\n      );\n\n      return Doc.concat([module, Doc.hardline, printDefineTypeAsModule(name)]);\n    }\n    case \"Synonym\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(\n            Doc.concat([\n              \"Definition\",\n              Doc.line,\n              name,\n              Doc.line,\n              \":\",\n              Doc.line,\n              \"Type\",\n              Doc.line,\n              \":=\",\n            ]),\n          ),\n          Doc.indent(\n            Doc.concat([Doc.line, Typ.print(false, typDefinition.typ), \".\"]),\n          ),\n        ]),\n      );\n    /* istanbul ignore next */\n    default:\n      return typDefinition;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Expression from \"./expression.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as TypDefinition from \"./typ-definition.js\";\n\nexport type t =\n  | {\n      type: \"Definition\",\n      arguments: Expression.FunArgument[],\n      body: Expression.t,\n      name: string,\n      returnTyp: ?Typ.t,\n      typParameters: string[],\n    }\n  | {\n      type: \"TypeDefinition\",\n      name: string,\n      typDefinition: TypDefinition.t,\n    };\n\nfunction* extractIdentifierOfLVal(\n  lval: BabelAst.LVal,\n): Monad.t<BabelAst.Identifier> {\n  switch (lval.type) {\n    case \"ArrayPattern\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Array destructuring at top-level is not allowed due to limitations in Coq\",\n      );\n    /* istanbul ignore next */\n    case \"AssignmentPattern\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Unexpected assignement pattern\",\n      );\n    case \"Identifier\":\n      return lval;\n    /* istanbul ignore next */\n    case \"MemberExpression\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Unexpected member expression\",\n      );\n    case \"ObjectPattern\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Object destructuring at top-level is not allowed due to limitations in Coq\",\n      );\n    /* istanbul ignore next */\n    case \"RestElement\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Rest element unexpected outside a pattern\",\n      );\n    /* istanbul ignore next */\n    default:\n      return lval;\n  }\n}\n\nexport function* compile(declaration: BabelAst.Statement): Monad.t<t[]> {\n  switch (declaration.type) {\n    case \"BlockStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Blocks are not handled at top-level\",\n      );\n    // `break` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"BreakStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `break` at top-level\",\n      );\n    case \"ClassDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Class declarations are not handled\",\n      );\n    // `continue` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"ContinueStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `continue` at top-level\",\n      );\n    case \"DebuggerStatement\":\n      return [];\n    case \"DeclareClass\":\n    case \"DeclareExportAllDeclaration\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareVariable\":\n      // We choose to ignore the concept of declaration for now, as we believe\n      // that everything should be public to do proofs.\n      return [];\n    case \"DoWhileStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Do-while loops are not handled\",\n      );\n    case \"EmptyStatement\":\n      return [];\n    case \"ExportAllDeclaration\":\n      return yield* Monad.raise<t[]>(declaration, \"Export all are not handled\");\n    case \"ExportDefaultDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Export default is not handled\",\n      );\n    case \"ExportNamedDeclaration\":\n      return declaration.declaration\n        ? yield* compile(declaration.declaration)\n        : yield* Monad.raise<t[]>(\n            declaration,\n            \"This kind of export is not handled\",\n          );\n    case \"ExpressionStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Top-level expressions are not handled\",\n      );\n    case \"ForInStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"For-in loops are not handled\",\n      );\n    case \"ForOfStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"For-of loops are not handled\",\n      );\n    case \"ForStatement\":\n      return yield* Monad.raise<t[]>(declaration, \"For loops are not handled\");\n    case \"FunctionDeclaration\": {\n      const fun = yield* Expression.compileFun(declaration);\n      const name = declaration.id\n        ? declaration.id.name\n        : // A top-level function always has a name.\n          /* istanbul ignore next */\n          yield* Monad.raise<string>(declaration, \"Expected named function\");\n\n      return [\n        {\n          type: \"Definition\",\n          arguments: fun.arguments,\n          body: fun.body,\n          name,\n          returnTyp: fun.returnTyp,\n          typParameters: fun.typParameters,\n        },\n      ];\n    }\n    case \"IfStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"If at top-level are not handled\",\n      );\n    case \"ImportDeclaration\": {\n      if (declaration.source.value === \"react\") {\n        return [];\n      }\n\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Only the imports from React are handled\",\n      );\n    }\n    case \"InterfaceDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Interface declarations are not handled\",\n      );\n    case \"LabeledStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Labeled statements are not handled\",\n      );\n    case \"OpaqueType\":\n      return [\n        {\n          type: \"TypeDefinition\",\n          name: Identifier.compile(declaration.id),\n          typDefinition: yield* TypDefinition.compile(declaration.impltype),\n        },\n      ];\n    // `return` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"ReturnStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `return` at top-level\",\n      );\n    case \"SwitchStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Top-level switch are not handled\",\n      );\n    case \"ThrowStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Throw statements are not handled\",\n      );\n    case \"TryStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Try statements are not handled\",\n      );\n    case \"TypeAlias\":\n      return [\n        {\n          type: \"TypeDefinition\",\n          name: Identifier.compile(declaration.id),\n          typDefinition: yield* TypDefinition.compile(declaration.right),\n        },\n      ];\n    case \"VariableDeclaration\":\n      return yield* Monad.all(\n        declaration.declarations.map(function*(declaration) {\n          const id = yield* extractIdentifierOfLVal(declaration.id);\n          const returnTyp = id.typeAnnotation\n            ? id.typeAnnotation.typeAnnotation\n            : null;\n\n          return {\n            type: \"Definition\",\n            arguments: [],\n            body: declaration.init\n              ? yield* Expression.compile(declaration.init)\n              : yield* Monad.raise<Expression.t>(\n                  declaration,\n                  \"Expected definition\",\n                ),\n            name: id.name,\n            returnTyp: returnTyp && (yield* Typ.compile(returnTyp)),\n            typParameters: [],\n          };\n        }),\n      );\n    case \"WhileStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"While loops are not handled\",\n      );\n    // The `with` keyword is forbidden as we are in strict mode.\n    /* istanbul ignore next */\n    case \"WithStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"With statements are not handled\",\n      );\n    /* istanbul ignore next */\n    default:\n      return declaration;\n  }\n}\n\nexport function print(declaration: t): Doc.t {\n  switch (declaration.type) {\n    case \"Definition\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(Doc.concat([\"Definition\", Doc.line, declaration.name])),\n          Doc.indent(\n            Doc.concat([\n              ...(declaration.typParameters.length !== 0\n                ? [Doc.line, Typ.printImplicitTyps(declaration.typParameters)]\n                : []),\n              Expression.printFunArguments(declaration.arguments),\n              Doc.line,\n              Typ.printReturnTyp(declaration.returnTyp, \":=\"),\n              Doc.hardline,\n              Expression.print(false, declaration.body),\n              \".\",\n            ]),\n          ),\n        ]),\n      );\n    case \"TypeDefinition\":\n      return TypDefinition.print(declaration.name, declaration.typDefinition);\n    /* istanbul ignore next */\n    default:\n      return declaration;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Monad from \"./monad.js\";\nimport * as TopLevelStatement from \"./top-level-statement.js\";\n\nexport type t = TopLevelStatement.t[];\n\nexport function* compile(program: BabelAst.Program): Monad.t<t> {\n  const unflattenedStatements = yield* Monad.all(\n    program.body.map(statement => TopLevelStatement.compile(statement)),\n  );\n\n  return unflattenedStatements.reduce(\n    (accumulator: t, statements: TopLevelStatement.t[]) => [\n      ...accumulator,\n      ...statements,\n    ],\n    [],\n  );\n}\n\nexport function print(program: t, withHeader: boolean): Doc.t {\n  return Doc.group(\n    Doc.join(Doc.concat([Doc.hardline, Doc.hardline]), [\n      ...(withHeader\n        ? [\n            `(* Generated by coq-of-js *)\nRequire Import Coq.Lists.List.\nRequire Import Coq.Strings.String.\nRequire Import Coq.ZArith.ZArith.\n\nImport ListNotations.\nLocal Open Scope string.\nLocal Open Scope Z.`,\n          ]\n        : []),\n      ...program.map(programElement => TopLevelStatement.print(programElement)),\n    ]),\n  );\n}\n","// @flow\n\nexport default `/* Basic definitions */\n\nconst\n  b: boolean = false && true,\n  n: number = -12 + 23;\n\nconst s = \"hi\";\n\nconst a = [1, (2 : number), 3];\n\nconst cond = b ? \"a\" : 'b';\n\n/* Functions */\n\nfunction id<A>(x: A): A {\n  return x;\n}\n\nfunction basicTypes(n: number, m: number): string {\n  return \"OK\";\n}\n\nconst r = id(basicTypes(12, 23));\n\nconst f = function<A> (x : A, y : A): bool {\n  return true;\n}\n\nconst arrow = x => x + 1;\n\n/* Records */\n\ntype Rec = {\n  a: string,\n  b: number,\n  c: boolean\n};\n\nconst o = ({a: \"hi\", b: 12, c: false}: Rec);\n\nconst hi = (o: Rec).a;\n\nconst getHi = (o: Rec) => {\n  const {a: hi}: Rec = o;\n  return hi;\n};\n\n/* Enums */\n\ntype Enum = \"aa\" | \"bb\" | \"gg\";\n\nconst aa = (\"aa\": Enum);\n\nfunction getEnumIndex(e: Enum): number {\n  switch ((e: Enum)) {\n    case \"aa\":\n      return 0;\n    case \"bb\":\n      return 1;\n    default:\n      return 2;\n  }\n}\n\n/* Algebraic data types */\n\ntype Status =\n  | {\n      type: \"Error\",\n      message: string,\n    }\n  | {\n      type: \"Loading\",\n    }\n  | {\n      type: \"Nothing\",\n    };\n\nconst status: Status = ({type: \"Error\", message: \"hi\"}: Status);\n\nfunction getMessage(status: Status): string {\n  switch ((status: Status).type) {\n    case \"Error\": {\n      const {message} = status;\n      return message;\n    }\n    case \"Loading\":\n      return \"loading...\";\n    case \"Nothing\":\n      return \"\";\n    default:\n      return (status: empty);\n  }\n}\n`;\n","// @flow\nimport React, {PureComponent} from \"react\";\n\ntype Props = {\n  output: string,\n};\n\nexport default class CoqOutput extends PureComponent<Props> {\n  render() {\n    const {output} = this.props;\n\n    return (\n      <code>\n        <pre>{output}</pre>\n      </code>\n    );\n  }\n}\n","// @flow\nimport React, {PureComponent} from \"react\";\nimport codeFrame from \"babel-code-frame\";\nimport {parse} from \"@babel/parser\";\nimport doc from \"prettier/doc.js\";\nimport * as BabelAst from \"./compiler/babel-ast.js\";\nimport * as Error from \"./compiler/error.js\";\nimport * as Monad from \"./compiler/monad.js\";\nimport * as Program from \"./compiler/program.js\";\nimport demoInput from \"./demoInput.js\";\nimport Output from \"./Output.js\";\nimport \"./App.css\";\n\ntype Props = {};\n\ntype State = {\n  jsInput: string,\n};\n\nfunction getInitialJsInput(): string {\n  if (typeof window !== \"undefined\") {\n    const item = window.sessionStorage.getItem(\"jsInput\");\n\n    return typeof item === \"string\" ? item : demoInput;\n  }\n\n  return demoInput;\n}\n\nexport default class App extends PureComponent<Props, State> {\n  state: State = {\n    jsInput: getInitialJsInput(),\n  };\n\n  onChangeJsInput = (event: SyntheticEvent<HTMLTextAreaElement>) => {\n    const {value} = event.currentTarget;\n\n    this.setState({jsInput: value});\n\n    if (typeof window !== \"undefined\") {\n      window.sessionStorage.setItem(\"jsInput\", value);\n    }\n  };\n\n  getJsAst(jsInput: string): BabelAst.File | string {\n    try {\n      const ast = parse(jsInput, {\n        plugins: [\"flow\", \"jsx\"],\n        sourceType: \"module\",\n      });\n\n      return ast;\n    } catch (error) {\n      const {loc} = error;\n\n      return `${error.message}\\n\\n${codeFrame(jsInput, loc.line, loc.column)}`;\n    }\n  }\n\n  getCoqAst(source: string, jsAst: BabelAst.File): Program.t | string {\n    try {\n      const result = Monad.run(Program.compile(jsAst.program));\n\n      switch (result.type) {\n        case \"Error\":\n          return Error.print(source, result.errors);\n        case \"Success\":\n          return result.value;\n        default:\n          return result;\n      }\n    } catch (error) {\n      return error.message;\n    }\n  }\n\n  getCoqString(coqAst: Program.t): string {\n    return doc.printer.printDocToString(Program.print(coqAst, true), {\n      printWidth: 60,\n      tabWidth: 2,\n    }).formatted;\n  }\n\n  getOutputs(jsInput: string): {coq: string, coqAst: string, jsAst: string} {\n    const jsAst = this.getJsAst(jsInput);\n\n    if (typeof jsAst === \"string\") {\n      return {coq: jsAst, coqAst: \"\", jsAst: \"\"};\n    }\n\n    const coqAst = this.getCoqAst(jsInput, jsAst);\n\n    if (typeof coqAst === \"string\") {\n      return {coq: coqAst, coqAst: \"\", jsAst: \"\"};\n    }\n\n    return {\n      coq: this.getCoqString(coqAst),\n      coqAst: JSON.stringify(coqAst, null, 2),\n      jsAst: JSON.stringify(jsAst, null, 2),\n    };\n  }\n\n  render() {\n    const {jsInput} = this.state;\n    const {coq, coqAst, jsAst} = this.getOutputs(jsInput);\n\n    return (\n      <div>\n        <div className=\"header\">\n          <h1>\n            <span className=\"logo\">\n              <span aria-label=\"globe\" role=\"img\">\n                🌍\n              </span>{\" \"}\n              <span aria-label=\"rooster\" role=\"img\">\n                🐓\n              </span>\n            </span>\n            coq-of-js\n            <a className=\"sub-title\" href=\"https://github.com/clarus/coq-of-js\">\n              Sources\n            </a>\n          </h1>\n        </div>\n        <div className=\"split js-source\">\n          <h2>JavaScript editor</h2>\n          <textarea onChange={this.onChangeJsInput} value={jsInput} />\n        </div>\n        <div className=\"split coq-source\">\n          <h2>Generated Coq</h2>\n          <Output output={coq} />\n        </div>\n        <div className=\"split js-ast\">\n          <h2>JavaScript AST</h2>\n          <Output output={jsAst} />\n        </div>\n        <div className=\"split coq-ast\">\n          <h2>Coq AST</h2>\n          <Output output={coqAst} />\n        </div>\n      </div>\n    );\n  }\n}\n","// @flow\nimport {codeFrameColumns} from \"@babel/code-frame\";\nimport * as BabelAst from \"./babel-ast.js\";\n\nexport type t = {\n  location: ?BabelAst.SourceLocation,\n  message: string,\n};\n\nexport function print(source: string, errors: t[]): string {\n  return errors\n    .map(error => {\n      const errorSourceCode = codeFrameColumns(source, error.location);\n\n      return `${errorSourceCode}\\n\\n${error.message}`;\n    })\n    .join(\"\\n\\n**********************\\n\\n\");\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\",\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\",\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\",\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","// @flow\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst rootElement = document.getElementById(\"root\");\n\nif (rootElement) {\n  ReactDOM.render(<App />, rootElement);\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}