// @flow
import {compileAndPrint} from "../index.js";

describe("header", () => {
  it("can include header", () => {
    expect(compileAndPrint(`const x = 12;`, true)).toMatchInlineSnapshot(`
      "(* Generated by coq-of-js *)
      Require Import Coq.Lists.List.
      Require Import Coq.Strings.String.
      Require Import Coq.ZArith.ZArith.

      Import ListNotations.
      Local Open Scope string.
      Local Open Scope Z.

      Definition x :=
        12."
    `);
  });
});

describe("empty statements", () => {
  it("handles empty statements", () => {
    expect(compileAndPrint(`function foo() {}`)).toMatchInlineSnapshot(`
      "Definition foo :=
        tt."
    `);
  });
});

describe("returns", () => {
  it("handles returns", () => {
    expect(compileAndPrint(`function foo() {return 12;}`))
      .toMatchInlineSnapshot(`
      "Definition foo :=
        12."
    `);
  });

  it("handles empty returns", () => {
    expect(compileAndPrint(`function foo() {return;}`)).toMatchInlineSnapshot(`
      "Definition foo :=
        tt."
    `);
  });
});

describe("destructuring of enums", () => {
  it("handles destructuring of enums", () => {
    expect(
      compileAndPrint(`
function foo() {
  switch ((s: Status)) {
    case "OK":
      return true;
    case "Error":
      return false;
  }
}
`),
    ).toMatchInlineSnapshot(`
      "Definition foo :=
        match s with
        | Status.OK => true
        | Status.Error => false
        end."
    `);
  });

  it("does not handle default cases", () => {
    expect(
      compileAndPrint(`
function foo() {
  switch ((s: Status)) {
    default:
      return true;
  }
}
`),
    ).toMatchInlineSnapshot(`
      "  2 | function foo() {
        3 |   switch ((s: Status)) {
      > 4 |     default:
          |    ^^^^^^^^
      > 5 |       return true;
          | ^^^^^^^^^^^^^^^^^^
        6 |   }
        7 | }
        8 | 

      Unhandled default case"
    `);
  });

  it("expects a type annotation on the discriminant", () => {
    expect(
      compileAndPrint(`
function foo() {
  switch (s) {
    case "OK":
      return true;
    case "Error":
      return false;
  }
}
`),
    ).toMatchInlineSnapshot(`
      "  1 | 
        2 | function foo() {
      > 3 |   switch (s) {
          |          ^
        4 |     case \\"OK\\":
        5 |       return true;
        6 |     case \\"Error\\":

      Missing type annotation"
    `);
  });
});

describe("definition of variables", () => {
  it("handles definitions of variables", () => {
    expect(compileAndPrint(`function foo() {const x = 12;}`))
      .toMatchInlineSnapshot(`
      "Definition foo :=
        let x := 12 in
        tt."
    `);
  });

  it("does not handle simultaneous definitions", () => {
    expect(compileAndPrint(`function foo() {const x = 12, b = false;}`))
      .toMatchInlineSnapshot(`
      "> 1 | function foo() {const x = 12, b = false;}
          |                ^^^^^^^^^^^^^^^^^^^^^^^^

      Expected exactly one definition"
    `);
  });

  it("does not handle empty definitions", () => {
    expect(compileAndPrint(`function foo() {var x;}`)).toMatchInlineSnapshot(`
      "> 1 | function foo() {var x;}
          |                    ^

      Expected definition"
    `);
  });
});

describe("destructuring of arrays", () => {
  it("does not handle destructuring of arrays", () => {
    expect(
      compileAndPrint(`
function foo() {
  const [a] = [1, 2];
  return a;
}
`),
    ).toMatchInlineSnapshot(`
      "  1 | 
        2 | function foo() {
      > 3 |   const [a] = [1, 2];
          |        ^^^
        4 |   return a;
        5 | }
        6 | 

      Unhandled array patterns"
    `);
  });
});

describe("destructuring of records by definition of variables", () => {
  it("handles destructuring of records", () => {
    expect(compileAndPrint(`function foo() {const {a, b}: Rec = o;}`))
      .toMatchInlineSnapshot(`
      "Definition foo :=
        let '{| Rec.a := a; Rec.b := b; |} := o in
        tt."
    `);
  });

  it("requires a type annotation", () => {
    expect(compileAndPrint(`function foo() {const {a, b} = o;}`))
      .toMatchInlineSnapshot(`
      "> 1 | function foo() {const {a, b} = o;}
          |                      ^^^^^^

      Expected a type annotation for the destructuring"
    `);
  });

  it("requires strings for the field names", () => {
    expect(compileAndPrint(`function foo() {const {["a" + "b"]: v}: Rec = o;}`))
      .toMatchInlineSnapshot(`
      "> 1 | function foo() {const {[\\"a\\" + \\"b\\"]: v}: Rec = o;}
          |                        ^^^^^^^^^

      Computed key name not handled"
    `);
  });

  it("requires identifiers for the field values", () => {
    expect(compileAndPrint(`function foo() {const {a: {v}}: Rec = o;}`))
      .toMatchInlineSnapshot(`
      "> 1 | function foo() {const {a: {v}}: Rec = o;}
          |                          ^^^

      Expected an identifier"
    `);
  });

  it("does not recognize spread patterns", () => {
    expect(compileAndPrint(`function foo() {const {...a}: Rec = o;}`))
      .toMatchInlineSnapshot(`
      "> 1 | function foo() {const {...a}: Rec = o;}
          |                       ^^^^

      Unhandled pattern field"
    `);
  });
});

describe("while loops", () => {
  it("does not handle while loops", () => {
    expect(
      compileAndPrint(`
function foo() {
  while (true) {};
}
`),
    ).toMatchInlineSnapshot(`
      "  1 | 
        2 | function foo() {
      > 3 |   while (true) {};
          |  ^^^^^^^^^^^^^^^
        4 | }
        5 | 

      Unhandled syntax:
      {
        \\"type\\": \\"WhileStatement\\",
        \\"start\\": 20,
        \\"end\\": 35,
        \\"loc\\": {
          \\"start\\": {
            \\"line\\": 3,
            \\"column\\": 2
          },
          \\"end\\": {
            \\"line\\": 3,
            \\"column\\": 17
          }
        },
        \\"test\\": {
          \\"type\\": \\"BooleanLiteral\\",
          \\"start\\": 27,
          \\"end\\": 31,
          \\"loc\\": {
            \\"start\\": {
              \\"line\\": 3,
              \\"column\\": 9
            },
            \\"end\\": {
              \\"line\\": 3,
              \\"column\\": 13
            }
          },
          \\"value\\": true
        },
        \\"body\\": {
          \\"type\\": \\"BlockStatement\\",
          \\"start\\": 33,
          \\"end\\": 35,
          \\"loc\\": {
            \\"start\\": {
              \\"line\\": 3,
              \\"column\\": 15
            },
            \\"end\\": {
              \\"line\\": 3,
              \\"column\\": 17
            }
          },
          \\"body\\": [],
          \\"directives\\": []
        }
      }"
    `);
  });
});
